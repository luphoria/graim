(function(){var __webpack_modules__={"./assets/js/prism.js":
/*!****************************!*\
  !*** ./assets/js/prism.js ***!
  \****************************/function(module,__unused_webpack_exports,__webpack_require__){eval('/* PrismJS 1.24.1\nhttps://prismjs.com/download.html#themes=prism-tomorrow&languages=markup+css+clike+javascript+actionscript+apacheconf+applescript+bash+c+csharp+cpp+cmake+coffeescript+csp+css-extras+diff+django+docker+elixir+elm+erlang+fsharp+flow+git+go+graphql+haml+handlebars+haskell+http+java+json+kotlin+latex+less+llvm+makefile+markdown+markup-templating+nasm+objectivec+ocaml+perl+php+php-extras+powershell+processing+pug+python+r+jsx+tsx+reason+ruby+rust+sass+scss+scala+scheme+sql+stylus+swift+textile+toml+twig+typescript+vim+visual-basic+wasm+yaml&plugins=line-highlight+line-numbers+jsonp-highlight+highlight-keywords+command-line+toolbar+copy-to-clipboard */\nvar _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {},\n    Prism = function (u) {\n  var c = /\\blang(?:uage)?-([\\w-]+)\\b/i,\n      n = 0,\n      e = {},\n      M = {\n    manual: u.Prism && u.Prism.manual,\n    disableWorkerMessageHandler: u.Prism && u.Prism.disableWorkerMessageHandler,\n    util: {\n      encode: function e(n) {\n        return n instanceof W ? new W(n.type, e(n.content), n.alias) : Array.isArray(n) ? n.map(e) : n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\\u00a0/g, " ");\n      },\n      type: function type(e) {\n        return Object.prototype.toString.call(e).slice(8, -1);\n      },\n      objId: function objId(e) {\n        return e.__id || Object.defineProperty(e, "__id", {\n          value: ++n\n        }), e.__id;\n      },\n      clone: function t(e, r) {\n        var a, n;\n\n        switch (r = r || {}, M.util.type(e)) {\n          case "Object":\n            if (n = M.util.objId(e), r[n]) return r[n];\n\n            for (var i in a = {}, r[n] = a, e) {\n              e.hasOwnProperty(i) && (a[i] = t(e[i], r));\n            }\n\n            return a;\n\n          case "Array":\n            return n = M.util.objId(e), r[n] ? r[n] : (a = [], r[n] = a, e.forEach(function (e, n) {\n              a[n] = t(e, r);\n            }), a);\n\n          default:\n            return e;\n        }\n      },\n      getLanguage: function getLanguage(e) {\n        for (; e && !c.test(e.className);) {\n          e = e.parentElement;\n        }\n\n        return e ? (e.className.match(c) || [, "none"])[1].toLowerCase() : "none";\n      },\n      currentScript: function currentScript() {\n        if ("undefined" == typeof document) return null;\n        if ("currentScript" in document) return document.currentScript;\n\n        try {\n          throw new Error();\n        } catch (e) {\n          var n = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(e.stack) || [])[1];\n\n          if (n) {\n            var t = document.getElementsByTagName("script");\n\n            for (var r in t) {\n              if (t[r].src == n) return t[r];\n            }\n          }\n\n          return null;\n        }\n      },\n      isActive: function isActive(e, n, t) {\n        for (var r = "no-" + n; e;) {\n          var a = e.classList;\n          if (a.contains(n)) return !0;\n          if (a.contains(r)) return !1;\n          e = e.parentElement;\n        }\n\n        return !!t;\n      }\n    },\n    languages: {\n      plain: e,\n      plaintext: e,\n      text: e,\n      txt: e,\n      extend: function extend(e, n) {\n        var t = M.util.clone(M.languages[e]);\n\n        for (var r in n) {\n          t[r] = n[r];\n        }\n\n        return t;\n      },\n      insertBefore: function insertBefore(t, e, n, r) {\n        var a = (r = r || M.languages)[t],\n            i = {};\n\n        for (var l in a) {\n          if (a.hasOwnProperty(l)) {\n            if (l == e) for (var o in n) {\n              n.hasOwnProperty(o) && (i[o] = n[o]);\n            }\n            n.hasOwnProperty(l) || (i[l] = a[l]);\n          }\n        }\n\n        var s = r[t];\n        return r[t] = i, M.languages.DFS(M.languages, function (e, n) {\n          n === s && e != t && (this[e] = i);\n        }), i;\n      },\n      DFS: function e(n, t, r, a) {\n        a = a || {};\n        var i = M.util.objId;\n\n        for (var l in n) {\n          if (n.hasOwnProperty(l)) {\n            t.call(n, l, n[l], r || l);\n            var o = n[l],\n                s = M.util.type(o);\n            "Object" !== s || a[i(o)] ? "Array" !== s || a[i(o)] || (a[i(o)] = !0, e(o, t, l, a)) : (a[i(o)] = !0, e(o, t, null, a));\n          }\n        }\n      }\n    },\n    plugins: {},\n    highlightAll: function highlightAll(e, n) {\n      M.highlightAllUnder(document, e, n);\n    },\n    highlightAllUnder: function highlightAllUnder(e, n, t) {\n      var r = {\n        callback: t,\n        container: e,\n        selector: \'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code\'\n      };\n      M.hooks.run("before-highlightall", r), r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)), M.hooks.run("before-all-elements-highlight", r);\n\n      for (var a, i = 0; a = r.elements[i++];) {\n        M.highlightElement(a, !0 === n, r.callback);\n      }\n    },\n    highlightElement: function highlightElement(e, n, t) {\n      var r = M.util.getLanguage(e),\n          a = M.languages[r];\n      e.className = e.className.replace(c, "").replace(/\\s+/g, " ") + " language-" + r;\n      var i = e.parentElement;\n      i && "pre" === i.nodeName.toLowerCase() && (i.className = i.className.replace(c, "").replace(/\\s+/g, " ") + " language-" + r);\n      var l = {\n        element: e,\n        language: r,\n        grammar: a,\n        code: e.textContent\n      };\n\n      function o(e) {\n        l.highlightedCode = e, M.hooks.run("before-insert", l), l.element.innerHTML = l.highlightedCode, M.hooks.run("after-highlight", l), M.hooks.run("complete", l), t && t.call(l.element);\n      }\n\n      if (M.hooks.run("before-sanity-check", l), (i = l.element.parentElement) && "pre" === i.nodeName.toLowerCase() && !i.hasAttribute("tabindex") && i.setAttribute("tabindex", "0"), !l.code) return M.hooks.run("complete", l), void (t && t.call(l.element));\n      if (M.hooks.run("before-highlight", l), l.grammar) {\n        if (n && u.Worker) {\n          var s = new Worker(M.filename);\n          s.onmessage = function (e) {\n            o(e.data);\n          }, s.postMessage(JSON.stringify({\n            language: l.language,\n            code: l.code,\n            immediateClose: !0\n          }));\n        } else o(M.highlight(l.code, l.grammar, l.language));\n      } else o(M.util.encode(l.code));\n    },\n    highlight: function highlight(e, n, t) {\n      var r = {\n        code: e,\n        grammar: n,\n        language: t\n      };\n      return M.hooks.run("before-tokenize", r), r.tokens = M.tokenize(r.code, r.grammar), M.hooks.run("after-tokenize", r), W.stringify(M.util.encode(r.tokens), r.language);\n    },\n    tokenize: function tokenize(e, n) {\n      var t = n.rest;\n\n      if (t) {\n        for (var r in t) {\n          n[r] = t[r];\n        }\n\n        delete n.rest;\n      }\n\n      var a = new i();\n      return I(a, a.head, e), function e(n, t, r, a, i, l) {\n        for (var o in r) {\n          if (r.hasOwnProperty(o) && r[o]) {\n            var s = r[o];\n            s = Array.isArray(s) ? s : [s];\n\n            for (var u = 0; u < s.length; ++u) {\n              if (l && l.cause == o + "," + u) return;\n              var c = s[u],\n                  g = c.inside,\n                  f = !!c.lookbehind,\n                  h = !!c.greedy,\n                  d = c.alias;\n\n              if (h && !c.pattern.global) {\n                var p = c.pattern.toString().match(/[imsuy]*$/)[0];\n                c.pattern = RegExp(c.pattern.source, p + "g");\n              }\n\n              for (var v = c.pattern || c, m = a.next, y = i; m !== t.tail && !(l && y >= l.reach); y += m.value.length, m = m.next) {\n                var b = m.value;\n                if (t.length > n.length) return;\n\n                if (!(b instanceof W)) {\n                  var k,\n                      x = 1;\n\n                  if (h) {\n                    if (!(k = z(v, y, n, f))) break;\n                    var w = k.index,\n                        A = k.index + k[0].length,\n                        P = y;\n\n                    for (P += m.value.length; P <= w;) {\n                      m = m.next, P += m.value.length;\n                    }\n\n                    if (P -= m.value.length, y = P, m.value instanceof W) continue;\n\n                    for (var E = m; E !== t.tail && (P < A || "string" == typeof E.value); E = E.next) {\n                      x++, P += E.value.length;\n                    }\n\n                    x--, b = n.slice(y, P), k.index -= y;\n                  } else if (!(k = z(v, 0, b, f))) continue;\n\n                  var w = k.index,\n                      S = k[0],\n                      O = b.slice(0, w),\n                      L = b.slice(w + S.length),\n                      N = y + b.length;\n                  l && N > l.reach && (l.reach = N);\n                  var j = m.prev;\n                  O && (j = I(t, j, O), y += O.length), q(t, j, x);\n                  var C = new W(o, g ? M.tokenize(S, g) : S, d, S);\n\n                  if (m = I(t, j, C), L && I(t, m, L), 1 < x) {\n                    var _ = {\n                      cause: o + "," + u,\n                      reach: N\n                    };\n                    e(n, t, r, m.prev, y, _), l && _.reach > l.reach && (l.reach = _.reach);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }(e, a, n, a.head, 0), function (e) {\n        var n = [],\n            t = e.head.next;\n\n        for (; t !== e.tail;) {\n          n.push(t.value), t = t.next;\n        }\n\n        return n;\n      }(a);\n    },\n    hooks: {\n      all: {},\n      add: function add(e, n) {\n        var t = M.hooks.all;\n        t[e] = t[e] || [], t[e].push(n);\n      },\n      run: function run(e, n) {\n        var t = M.hooks.all[e];\n        if (t && t.length) for (var r, a = 0; r = t[a++];) {\n          r(n);\n        }\n      }\n    },\n    Token: W\n  };\n\n  function W(e, n, t, r) {\n    this.type = e, this.content = n, this.alias = t, this.length = 0 | (r || "").length;\n  }\n\n  function z(e, n, t, r) {\n    e.lastIndex = n;\n    var a = e.exec(t);\n\n    if (a && r && a[1]) {\n      var i = a[1].length;\n      a.index += i, a[0] = a[0].slice(i);\n    }\n\n    return a;\n  }\n\n  function i() {\n    var e = {\n      value: null,\n      prev: null,\n      next: null\n    },\n        n = {\n      value: null,\n      prev: e,\n      next: null\n    };\n    e.next = n, this.head = e, this.tail = n, this.length = 0;\n  }\n\n  function I(e, n, t) {\n    var r = n.next,\n        a = {\n      value: t,\n      prev: n,\n      next: r\n    };\n    return n.next = a, r.prev = a, e.length++, a;\n  }\n\n  function q(e, n, t) {\n    for (var r = n.next, a = 0; a < t && r !== e.tail; a++) {\n      r = r.next;\n    }\n\n    (n.next = r).prev = n, e.length -= a;\n  }\n\n  if (u.Prism = M, W.stringify = function n(e, t) {\n    if ("string" == typeof e) return e;\n\n    if (Array.isArray(e)) {\n      var r = "";\n      return e.forEach(function (e) {\n        r += n(e, t);\n      }), r;\n    }\n\n    var a = {\n      type: e.type,\n      content: n(e.content, t),\n      tag: "span",\n      classes: ["token", e.type],\n      attributes: {},\n      language: t\n    },\n        i = e.alias;\n    i && (Array.isArray(i) ? Array.prototype.push.apply(a.classes, i) : a.classes.push(i)), M.hooks.run("wrap", a);\n    var l = "";\n\n    for (var o in a.attributes) {\n      l += " " + o + \'="\' + (a.attributes[o] || "").replace(/"/g, "&quot;") + \'"\';\n    }\n\n    return "<" + a.tag + \' class="\' + a.classes.join(" ") + \'"\' + l + ">" + a.content + "</" + a.tag + ">";\n  }, !u.document) return u.addEventListener && (M.disableWorkerMessageHandler || u.addEventListener("message", function (e) {\n    var n = JSON.parse(e.data),\n        t = n.language,\n        r = n.code,\n        a = n.immediateClose;\n    u.postMessage(M.highlight(r, M.languages[t], t)), a && u.close();\n  }, !1)), M;\n  var t = M.util.currentScript();\n\n  function r() {\n    M.manual || M.highlightAll();\n  }\n\n  if (t && (M.filename = t.src, t.hasAttribute("data-manual") && (M.manual = !0)), !M.manual) {\n    var a = document.readyState;\n    "loading" === a || "interactive" === a && t && t.defer ? document.addEventListener("DOMContentLoaded", r) : window.requestAnimationFrame ? window.requestAnimationFrame(r) : window.setTimeout(r, 16);\n  }\n\n  return M;\n}(_self);\n\n true && module.exports && (module.exports = Prism), "undefined" != typeof __webpack_require__.g && (__webpack_require__.g.Prism = Prism);\nPrism.languages.markup = {\n  comment: /\x3c!--[\\s\\S]*?--\x3e/,\n  prolog: /<\\?[\\s\\S]+?\\?>/,\n  doctype: {\n    pattern: /<!DOCTYPE(?:[^>"\'[\\]]|"[^"]*"|\'[^\']*\')+(?:\\[(?:[^<"\'\\]]|"[^"]*"|\'[^\']*\'|<(?!!--)|\x3c!--(?:[^-]|-(?!->))*--\x3e)*\\]\\s*)?>/i,\n    greedy: !0,\n    inside: {\n      "internal-subset": {\n        pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n        lookbehind: !0,\n        greedy: !0,\n        inside: null\n      },\n      string: {\n        pattern: /"[^"]*"|\'[^\']*\'/,\n        greedy: !0\n      },\n      punctuation: /^<!|>$|[[\\]]/,\n      "doctype-tag": /^DOCTYPE/,\n      name: /[^\\s<>\'"]+/\n    }\n  },\n  cdata: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n  tag: {\n    pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:"[^"]*"|\'[^\']*\'|[^\\s\'">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n    greedy: !0,\n    inside: {\n      tag: {\n        pattern: /^<\\/?[^\\s>\\/]+/,\n        inside: {\n          punctuation: /^<\\/?/,\n          namespace: /^[^\\s>\\/:]+:/\n        }\n      },\n      "special-attr": [],\n      "attr-value": {\n        pattern: /=\\s*(?:"[^"]*"|\'[^\']*\'|[^\\s\'">=]+)/,\n        inside: {\n          punctuation: [{\n            pattern: /^=/,\n            alias: "attr-equals"\n          }, /"|\'/]\n        }\n      },\n      punctuation: /\\/?>/,\n      "attr-name": {\n        pattern: /[^\\s>\\/]+/,\n        inside: {\n          namespace: /^[^\\s>\\/:]+:/\n        }\n      }\n    }\n  },\n  entity: [{\n    pattern: /&[\\da-z]{1,8};/i,\n    alias: "named-entity"\n  }, /&#x?[\\da-f]{1,8};/i]\n}, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function (a) {\n  "entity" === a.type && (a.attributes.title = a.content.replace(/&amp;/, "&"));\n}), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {\n  value: function value(a, e) {\n    var s = {};\n    s["language-" + e] = {\n      pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n      lookbehind: !0,\n      inside: Prism.languages[e]\n    }, s.cdata = /^<!\\[CDATA\\[|\\]\\]>$/i;\n    var t = {\n      "included-cdata": {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        inside: s\n      }\n    };\n    t["language-" + e] = {\n      pattern: /[\\s\\S]+/,\n      inside: Prism.languages[e]\n    };\n    var n = {};\n    n[a] = {\n      pattern: RegExp("(<__[^>]*>)(?:<!\\\\[CDATA\\\\[(?:[^\\\\]]|\\\\](?!\\\\]>))*\\\\]\\\\]>|(?!<!\\\\[CDATA\\\\[)[^])*?(?=</__>)".replace(/__/g, function () {\n        return a;\n      }), "i"),\n      lookbehind: !0,\n      greedy: !0,\n      inside: t\n    }, Prism.languages.insertBefore("markup", "cdata", n);\n  }\n}), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {\n  value: function value(a, e) {\n    Prism.languages.markup.tag.inside["special-attr"].push({\n      pattern: RegExp("(^|[\\"\'\\\\s])(?:" + a + ")\\\\s*=\\\\s*(?:\\"[^\\"]*\\"|\'[^\']*\'|[^\\\\s\'\\">=]+(?=[\\\\s>]))", "i"),\n      lookbehind: !0,\n      inside: {\n        "attr-name": /^[^\\s=]+/,\n        "attr-value": {\n          pattern: /=[\\s\\S]+/,\n          inside: {\n            value: {\n              pattern: /(^=\\s*(["\']|(?!["\'])))\\S[\\s\\S]*(?=\\2$)/,\n              lookbehind: !0,\n              alias: [e, "language-" + e],\n              inside: Prism.languages[e]\n            },\n            punctuation: [{\n              pattern: /^=/,\n              alias: "attr-equals"\n            }, /"|\'/]\n          }\n        }\n      }\n    });\n  }\n}), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml;\n!function (s) {\n  var e = /(?:"(?:\\\\(?:\\r\\n|[\\s\\S])|[^"\\\\\\r\\n])*"|\'(?:\\\\(?:\\r\\n|[\\s\\S])|[^\'\\\\\\r\\n])*\')/;\n  s.languages.css = {\n    comment: /\\/\\*[\\s\\S]*?\\*\\//,\n    atrule: {\n      pattern: /@[\\w-](?:[^;{\\s]|\\s+(?![\\s{]))*(?:;|(?=\\s*\\{))/,\n      inside: {\n        rule: /^@[\\w-]+/,\n        "selector-function-argument": {\n          pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n          lookbehind: !0,\n          alias: "selector"\n        },\n        keyword: {\n          pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n          lookbehind: !0\n        }\n      }\n    },\n    url: {\n      pattern: RegExp("\\\\burl\\\\((?:" + e.source + "|(?:[^\\\\\\\\\\r\\n()\\"\']|\\\\\\\\[^])*)\\\\)", "i"),\n      greedy: !0,\n      inside: {\n        function: /^url/i,\n        punctuation: /^\\(|\\)$/,\n        string: {\n          pattern: RegExp("^" + e.source + "$"),\n          alias: "url"\n        }\n      }\n    },\n    selector: {\n      pattern: RegExp("(^|[{}\\\\s])[^{}\\\\s](?:[^{};\\"\'\\\\s]|\\\\s+(?![\\\\s{])|" + e.source + ")*(?=\\\\s*\\\\{)"),\n      lookbehind: !0\n    },\n    string: {\n      pattern: e,\n      greedy: !0\n    },\n    property: {\n      pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n      lookbehind: !0\n    },\n    important: /!important\\b/i,\n    function: {\n      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n      lookbehind: !0\n    },\n    punctuation: /[(){};:,]/\n  }, s.languages.css.atrule.inside.rest = s.languages.css;\n  var t = s.languages.markup;\n  t && (t.tag.addInlined("style", "css"), t.tag.addAttribute("style", "css"));\n}(Prism);\nPrism.languages.clike = {\n  comment: [{\n    pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    lookbehind: !0,\n    greedy: !0\n  }, {\n    pattern: /(^|[^\\\\:])\\/\\/.*/,\n    lookbehind: !0,\n    greedy: !0\n  }],\n  string: {\n    pattern: /(["\'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: !0\n  },\n  "class-name": {\n    pattern: /(\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n    lookbehind: !0,\n    inside: {\n      punctuation: /[.\\\\]/\n    }\n  },\n  keyword: /\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n  boolean: /\\b(?:true|false)\\b/,\n  function: /\\b\\w+(?=\\()/,\n  number: /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n  operator: /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n  punctuation: /[{}[\\];(),.:]/\n};\nPrism.languages.javascript = Prism.languages.extend("clike", {\n  "class-name": [Prism.languages.clike["class-name"], {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:prototype|constructor))/,\n    lookbehind: !0\n  }],\n  keyword: [{\n    pattern: /((?:^|\\})\\s*)catch\\b/,\n    lookbehind: !0\n  }, {\n    pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:[\'"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n    lookbehind: !0\n  }],\n  function: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n  number: /\\b(?:(?:0[xX](?:[\\dA-Fa-f](?:_[\\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\\d(?:_\\d)?)+n|NaN|Infinity)\\b|(?:\\b(?:\\d(?:_\\d)?)+\\.?(?:\\d(?:_\\d)?)*|\\B\\.(?:\\d(?:_\\d)?)+)(?:[Ee][+-]?(?:\\d(?:_\\d)?)+)?/,\n  operator: /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n}), Prism.languages.javascript["class-name"][0].pattern = /(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/, Prism.languages.insertBefore("javascript", "keyword", {\n  regex: {\n    pattern: /((?:^|[^$\\w\\xA0-\\uFFFF."\'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,\n    lookbehind: !0,\n    greedy: !0,\n    inside: {\n      "regex-source": {\n        pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n        lookbehind: !0,\n        alias: "language-regex",\n        inside: Prism.languages.regex\n      },\n      "regex-delimiter": /^\\/|\\/$/,\n      "regex-flags": /^[a-z]+$/\n    }\n  },\n  "function-variable": {\n    pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n    alias: "function"\n  },\n  parameter: [{\n    pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n    lookbehind: !0,\n    inside: Prism.languages.javascript\n  }, {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n    lookbehind: !0,\n    inside: Prism.languages.javascript\n  }, {\n    pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n    lookbehind: !0,\n    inside: Prism.languages.javascript\n  }, {\n    pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n    lookbehind: !0,\n    inside: Prism.languages.javascript\n  }],\n  constant: /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n}), Prism.languages.insertBefore("javascript", "string", {\n  hashbang: {\n    pattern: /^#!.*/,\n    greedy: !0,\n    alias: "comment"\n  },\n  "template-string": {\n    pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n    greedy: !0,\n    inside: {\n      "template-punctuation": {\n        pattern: /^`|`$/,\n        alias: "string"\n      },\n      interpolation: {\n        pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n        lookbehind: !0,\n        inside: {\n          "interpolation-punctuation": {\n            pattern: /^\\$\\{|\\}$/,\n            alias: "punctuation"\n          },\n          rest: Prism.languages.javascript\n        }\n      },\n      string: /[\\s\\S]+/\n    }\n  }\n}), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute("on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)", "javascript")), Prism.languages.js = Prism.languages.javascript;\nPrism.languages.actionscript = Prism.languages.extend("javascript", {\n  keyword: /\\b(?:as|break|case|catch|class|const|default|delete|do|else|extends|finally|for|function|if|implements|import|in|instanceof|interface|internal|is|native|new|null|package|private|protected|public|return|super|switch|this|throw|try|typeof|use|var|void|while|with|dynamic|each|final|get|include|namespace|override|set|static)\\b/,\n  operator: /\\+\\+|--|(?:[+\\-*\\/%^]|&&?|\\|\\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/\n}), Prism.languages.actionscript["class-name"].alias = "function", Prism.languages.markup && Prism.languages.insertBefore("actionscript", "string", {\n  xml: {\n    pattern: /(^|[^.])<\\/?\\w+(?:\\s+[^\\s>\\/=]+=("|\')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\])*\\2)*\\s*\\/?>/,\n    lookbehind: !0,\n    inside: Prism.languages.markup\n  }\n});\nPrism.languages.apacheconf = {\n  comment: /#.*/,\n  "directive-inline": {\n    pattern: /(^[\\t ]*)\\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|Type|UserFile|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferSize|BufferedLogs|CGIDScriptTimeout|CGIMapExtension|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DTracePrivileges|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtFilterDefine|ExtFilterOptions|ExtendedStatus|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|KeepAlive|KeepAliveTimeout|KeptBodySize|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|LanguagePriority|Limit(?:InternalRecursion|Request(?:Body|FieldSize|Fields|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|MMapFile|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|ModMimeUsePathInfo|ModemStandard|MultiviewsMatch|Mutex|NWSSLTrustedCerts|NWSSLUpgradeable|NameVirtualHost|NoProxy|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|RLimitCPU|RLimitMEM|RLimitNPROC|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|SSIETag|SSIEndTag|SSIErrorMsg|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|SRPUnknownUserSeed|SRPVerifierFile|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UseStapling|UserName|VerifyClient|VerifyDepth)|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadStackSize|ThreadsPerChild|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\\b/im,\n    lookbehind: !0,\n    alias: "property"\n  },\n  "directive-block": {\n    pattern: /<\\/?\\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\\b.*>/i,\n    inside: {\n      "directive-block": {\n        pattern: /^<\\/?\\w+/,\n        inside: {\n          punctuation: /^<\\/?/\n        },\n        alias: "tag"\n      },\n      "directive-block-parameter": {\n        pattern: /.*[^>]/,\n        inside: {\n          punctuation: /:/,\n          string: {\n            pattern: /("|\').*\\1/,\n            inside: {\n              variable: /[$%]\\{?(?:\\w\\.?[-+:]?)+\\}?/\n            }\n          }\n        },\n        alias: "attr-value"\n      },\n      punctuation: />/\n    },\n    alias: "tag"\n  },\n  "directive-flags": {\n    pattern: /\\[(?:[\\w=],?)+\\]/,\n    alias: "keyword"\n  },\n  string: {\n    pattern: /("|\').*\\1/,\n    inside: {\n      variable: /[$%]\\{?(?:\\w\\.?[-+:]?)+\\}?/\n    }\n  },\n  variable: /[$%]\\{?(?:\\w\\.?[-+:]?)+\\}?/,\n  regex: /\\^?.*\\$|\\^.*\\$?/\n};\nPrism.languages.applescript = {\n  comment: [/\\(\\*(?:\\(\\*(?:[^*]|\\*(?!\\)))*\\*\\)|(?!\\(\\*)[\\s\\S])*?\\*\\)/, /--.+/, /#.+/],\n  string: /"(?:\\\\.|[^"\\\\\\r\\n])*"/,\n  number: /(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e-?\\d+)?\\b/i,\n  operator: [/[&=≠≤≥*+\\-\\/÷^]|[<>]=?/, /\\b(?:(?:start|begin|end)s? with|(?:(?:does not|doesn\'t) contain|contains?)|(?:is|isn\'t|is not) (?:in|contained by)|(?:(?:is|isn\'t|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:(?:does not|doesn\'t) come|comes) (?:before|after)|(?:is|isn\'t|is not) equal(?: to)?|(?:(?:does not|doesn\'t) equal|equals|equal to|isn\'t|is not)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|or|div|mod|as|not))\\b/],\n  keyword: /\\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\\b/,\n  class: {\n    pattern: /\\b(?:alias|application|boolean|class|constant|date|file|integer|list|number|POSIX file|real|record|reference|RGB color|script|text|centimetres|centimeters|feet|inches|kilometres|kilometers|metres|meters|miles|yards|square feet|square kilometres|square kilometers|square metres|square meters|square miles|square yards|cubic centimetres|cubic centimeters|cubic feet|cubic inches|cubic metres|cubic meters|cubic yards|gallons|litres|liters|quarts|grams|kilograms|ounces|pounds|degrees Celsius|degrees Fahrenheit|degrees Kelvin)\\b/,\n    alias: "builtin"\n  },\n  punctuation: /[{}():,¬«»《》]/\n};\n!function (e) {\n  var t = "\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b",\n      n = {\n    pattern: /(^(["\']?)\\w+\\2)[ \\t]+\\S.*/,\n    lookbehind: !0,\n    alias: "punctuation",\n    inside: null\n  },\n      a = {\n    bash: n,\n    environment: {\n      pattern: RegExp("\\\\$" + t),\n      alias: "constant"\n    },\n    variable: [{\n      pattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n      greedy: !0,\n      inside: {\n        variable: [{\n          pattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n          lookbehind: !0\n        }, /^\\$\\(\\(/],\n        number: /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n        operator: /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n        punctuation: /\\(\\(?|\\)\\)?|,|;/\n      }\n    }, {\n      pattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n      greedy: !0,\n      inside: {\n        variable: /^\\$\\(|^`|\\)$|`$/\n      }\n    }, {\n      pattern: /\\$\\{[^}]+\\}/,\n      greedy: !0,\n      inside: {\n        operator: /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n        punctuation: /[\\[\\]]/,\n        environment: {\n          pattern: RegExp("(\\\\{)" + t),\n          lookbehind: !0,\n          alias: "constant"\n        }\n      }\n    }, /\\$(?:\\w+|[#?*!@$])/],\n    entity: /\\\\(?:[abceEfnrtv\\\\"]|O?[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})/\n  };\n  e.languages.bash = {\n    shebang: {\n      pattern: /^#!\\s*\\/.*/,\n      alias: "important"\n    },\n    comment: {\n      pattern: /(^|[^"{\\\\$])#.*/,\n      lookbehind: !0\n    },\n    "function-name": [{\n      pattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n      lookbehind: !0,\n      alias: "function"\n    }, {\n      pattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n      alias: "function"\n    }],\n    "for-or-select": {\n      pattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n      alias: "variable",\n      lookbehind: !0\n    },\n    "assign-left": {\n      pattern: /(^|[\\s;|&]|[<>]\\()\\w+(?=\\+?=)/,\n      inside: {\n        environment: {\n          pattern: RegExp("(^|[\\\\s;|&]|[<>]\\\\()" + t),\n          lookbehind: !0,\n          alias: "constant"\n        }\n      },\n      alias: "variable",\n      lookbehind: !0\n    },\n    string: [{\n      pattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n      lookbehind: !0,\n      greedy: !0,\n      inside: a\n    }, {\n      pattern: /((?:^|[^<])<<-?\\s*)(["\'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        bash: n\n      }\n    }, {\n      pattern: /(^|[^\\\\](?:\\\\\\\\)*)"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^"\\\\`$])*"/,\n      lookbehind: !0,\n      greedy: !0,\n      inside: a\n    }, {\n      pattern: /(^|[^$\\\\])\'[^\']*\'/,\n      lookbehind: !0,\n      greedy: !0\n    }, {\n      pattern: /\\$\'(?:[^\'\\\\]|\\\\[\\s\\S])*\'/,\n      greedy: !0,\n      inside: {\n        entity: a.entity\n      }\n    }],\n    environment: {\n      pattern: RegExp("\\\\$?" + t),\n      alias: "constant"\n    },\n    variable: a.variable,\n    function: {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|aptitude|apt-cache|apt-get|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n      lookbehind: !0\n    },\n    keyword: {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:if|then|else|elif|fi|for|while|in|case|esac|function|select|do|done|until)(?=$|[)\\s;|&])/,\n      lookbehind: !0\n    },\n    builtin: {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|break|cd|continue|eval|exec|exit|export|getopts|hash|pwd|readonly|return|shift|test|times|trap|umask|unset|alias|bind|builtin|caller|command|declare|echo|enable|help|let|local|logout|mapfile|printf|read|readarray|source|type|typeset|ulimit|unalias|set|shopt)(?=$|[)\\s;|&])/,\n      lookbehind: !0,\n      alias: "class-name"\n    },\n    boolean: {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:true|false)(?=$|[)\\s;|&])/,\n      lookbehind: !0\n    },\n    "file-descriptor": {\n      pattern: /\\B&\\d\\b/,\n      alias: "important"\n    },\n    operator: {\n      pattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n      inside: {\n        "file-descriptor": {\n          pattern: /^\\d/,\n          alias: "important"\n        }\n      }\n    },\n    punctuation: /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n    number: {\n      pattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n      lookbehind: !0\n    }\n  }, n.inside = e.languages.bash;\n\n  for (var s = ["comment", "function-name", "for-or-select", "assign-left", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"], i = a.variable[1].inside, o = 0; o < s.length; o++) {\n    i[s[o]] = e.languages.bash[s[o]];\n  }\n\n  e.languages.shell = e.languages.bash;\n}(Prism);\nPrism.languages.c = Prism.languages.extend("clike", {\n  comment: {\n    pattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: !0\n  },\n  "class-name": {\n    pattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n    lookbehind: !0\n  },\n  keyword: /\\b(?:__attribute__|_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\\b/,\n  function: /\\b[a-z_]\\w*(?=\\s*\\()/i,\n  number: /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n  operator: />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n}), Prism.languages.insertBefore("c", "string", {\n  macro: {\n    pattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n    lookbehind: !0,\n    greedy: !0,\n    alias: "property",\n    inside: {\n      string: [{\n        pattern: /^(#\\s*include\\s*)<[^>]+>/,\n        lookbehind: !0\n      }, Prism.languages.c.string],\n      comment: Prism.languages.c.comment,\n      "macro-name": [{\n        pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n        lookbehind: !0\n      }, {\n        pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n        lookbehind: !0,\n        alias: "function"\n      }],\n      directive: {\n        pattern: /^(#\\s*)[a-z]+/,\n        lookbehind: !0,\n        alias: "keyword"\n      },\n      "directive-hash": /^#/,\n      punctuation: /##|\\\\(?=[\\r\\n])/,\n      expression: {\n        pattern: /\\S[\\s\\S]*/,\n        inside: Prism.languages.c\n      }\n    }\n  },\n  constant: /\\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\\b/\n}), delete Prism.languages.c.boolean;\n!function (s) {\n  function a(e, s) {\n    return e.replace(/<<(\\d+)>>/g, function (e, n) {\n      return "(?:" + s[+n] + ")";\n    });\n  }\n\n  function t(e, n, s) {\n    return RegExp(a(e, n), s || "");\n  }\n\n  function e(e, n) {\n    for (var s = 0; s < n; s++) {\n      e = e.replace(/<<self>>/g, function () {\n        return "(?:" + e + ")";\n      });\n    }\n\n    return e.replace(/<<self>>/g, "[^\\\\s\\\\S]");\n  }\n\n  var n = "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",\n      r = "class enum interface record struct",\n      i = "add alias and ascending async await by descending from(?=\\\\s*(?:\\\\w|$)) get global group into init(?=\\\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\\\s*{)",\n      o = "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield";\n\n  function l(e) {\n    return "\\\\b(?:" + e.trim().replace(/ /g, "|") + ")\\\\b";\n  }\n\n  var d = l(r),\n      p = RegExp(l(n + " " + r + " " + i + " " + o)),\n      c = l(r + " " + i + " " + o),\n      u = l(n + " " + r + " " + o),\n      g = e("<(?:[^<>;=+\\\\-*/%&|^]|<<self>>)*>", 2),\n      b = e("\\\\((?:[^()]|<<self>>)*\\\\)", 2),\n      h = "@?\\\\b[A-Za-z_]\\\\w*\\\\b",\n      f = a("<<0>>(?:\\\\s*<<1>>)?", [h, g]),\n      m = a("(?!<<0>>)<<1>>(?:\\\\s*\\\\.\\\\s*<<1>>)*", [c, f]),\n      k = "\\\\[\\\\s*(?:,\\\\s*)*\\\\]",\n      y = a("<<0>>(?:\\\\s*(?:\\\\?\\\\s*)?<<1>>)*(?:\\\\s*\\\\?)?", [m, k]),\n      w = a("(?:<<0>>|<<1>>)(?:\\\\s*(?:\\\\?\\\\s*)?<<2>>)*(?:\\\\s*\\\\?)?", [a("\\\\(<<0>>+(?:,<<0>>+)+\\\\)", [a("[^,()<>[\\\\];=+\\\\-*/%&|^]|<<0>>|<<1>>|<<2>>", [g, b, k])]), m, k]),\n      v = {\n    keyword: p,\n    punctuation: /[<>()?,.:[\\]]/\n  },\n      x = "\'(?:[^\\r\\n\'\\\\\\\\]|\\\\\\\\.|\\\\\\\\[Uux][\\\\da-fA-F]{1,8})\'",\n      $ = \'"(?:\\\\\\\\.|[^\\\\\\\\"\\r\\n])*"\';\n  s.languages.csharp = s.languages.extend("clike", {\n    string: [{\n      pattern: t("(^|[^$\\\\\\\\])<<0>>", [\'@"(?:""|\\\\\\\\[^]|[^\\\\\\\\"])*"(?!")\']),\n      lookbehind: !0,\n      greedy: !0\n    }, {\n      pattern: t("(^|[^@$\\\\\\\\])<<0>>", [$]),\n      lookbehind: !0,\n      greedy: !0\n    }, {\n      pattern: RegExp(x),\n      greedy: !0,\n      alias: "character"\n    }],\n    "class-name": [{\n      pattern: t("(\\\\busing\\\\s+static\\\\s+)<<0>>(?=\\\\s*;)", [m]),\n      lookbehind: !0,\n      inside: v\n    }, {\n      pattern: t("(\\\\busing\\\\s+<<0>>\\\\s*=\\\\s*)<<1>>(?=\\\\s*;)", [h, w]),\n      lookbehind: !0,\n      inside: v\n    }, {\n      pattern: t("(\\\\busing\\\\s+)<<0>>(?=\\\\s*=)", [h]),\n      lookbehind: !0\n    }, {\n      pattern: t("(\\\\b<<0>>\\\\s+)<<1>>", [d, f]),\n      lookbehind: !0,\n      inside: v\n    }, {\n      pattern: t("(\\\\bcatch\\\\s*\\\\(\\\\s*)<<0>>", [m]),\n      lookbehind: !0,\n      inside: v\n    }, {\n      pattern: t("(\\\\bwhere\\\\s+)<<0>>", [h]),\n      lookbehind: !0\n    }, {\n      pattern: t("(\\\\b(?:is(?:\\\\s+not)?|as)\\\\s+)<<0>>", [y]),\n      lookbehind: !0,\n      inside: v\n    }, {\n      pattern: t("\\\\b<<0>>(?=\\\\s+(?!<<1>>|with\\\\s*\\\\{)<<2>>(?:\\\\s*[=,;:{)\\\\]]|\\\\s+(?:in|when)\\\\b))", [w, u, h]),\n      inside: v\n    }],\n    keyword: p,\n    number: /(?:\\b0(?:x[\\da-f_]*[\\da-f]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[-+]?\\d+(?:_+\\d+)*)?)(?:ul|lu|[dflmu])?\\b/i,\n    operator: />>=?|<<=?|[-=]>|([-+&|])\\1|~|\\?\\?=?|[-+*/%&|^!=<>]=?/,\n    punctuation: /\\?\\.?|::|[{}[\\];(),.:]/\n  }), s.languages.insertBefore("csharp", "number", {\n    range: {\n      pattern: /\\.\\./,\n      alias: "operator"\n    }\n  }), s.languages.insertBefore("csharp", "punctuation", {\n    "named-parameter": {\n      pattern: t("([(,]\\\\s*)<<0>>(?=\\\\s*:)", [h]),\n      lookbehind: !0,\n      alias: "punctuation"\n    }\n  }), s.languages.insertBefore("csharp", "class-name", {\n    namespace: {\n      pattern: t("(\\\\b(?:namespace|using)\\\\s+)<<0>>(?:\\\\s*\\\\.\\\\s*<<0>>)*(?=\\\\s*[;{])", [h]),\n      lookbehind: !0,\n      inside: {\n        punctuation: /\\./\n      }\n    },\n    "type-expression": {\n      pattern: t("(\\\\b(?:default|typeof|sizeof)\\\\s*\\\\(\\\\s*(?!\\\\s))(?:[^()\\\\s]|\\\\s(?!\\\\s)|<<0>>)*(?=\\\\s*\\\\))", [b]),\n      lookbehind: !0,\n      alias: "class-name",\n      inside: v\n    },\n    "return-type": {\n      pattern: t("<<0>>(?=\\\\s+(?:<<1>>\\\\s*(?:=>|[({]|\\\\.\\\\s*this\\\\s*\\\\[)|this\\\\s*\\\\[))", [w, m]),\n      inside: v,\n      alias: "class-name"\n    },\n    "constructor-invocation": {\n      pattern: t("(\\\\bnew\\\\s+)<<0>>(?=\\\\s*[[({])", [w]),\n      lookbehind: !0,\n      inside: v,\n      alias: "class-name"\n    },\n    "generic-method": {\n      pattern: t("<<0>>\\\\s*<<1>>(?=\\\\s*\\\\()", [h, g]),\n      inside: {\n        function: t("^<<0>>", [h]),\n        generic: {\n          pattern: RegExp(g),\n          alias: "class-name",\n          inside: v\n        }\n      }\n    },\n    "type-list": {\n      pattern: t("\\\\b((?:<<0>>\\\\s+<<1>>|record\\\\s+<<1>>\\\\s*<<5>>|where\\\\s+<<2>>)\\\\s*:\\\\s*)(?:<<3>>|<<4>>|<<1>>\\\\s*<<5>>|<<6>>)(?:\\\\s*,\\\\s*(?:<<3>>|<<4>>|<<6>>))*(?=\\\\s*(?:where|[{;]|=>|$))", [d, f, h, w, p.source, b, "\\\\bnew\\\\s*\\\\(\\\\s*\\\\)"]),\n      lookbehind: !0,\n      inside: {\n        "record-arguments": {\n          pattern: t("(^(?!new\\\\s*\\\\()<<0>>\\\\s*)<<1>>", [f, b]),\n          lookbehind: !0,\n          greedy: !0,\n          inside: s.languages.csharp\n        },\n        keyword: p,\n        "class-name": {\n          pattern: RegExp(w),\n          greedy: !0,\n          inside: v\n        },\n        punctuation: /[,()]/\n      }\n    },\n    preprocessor: {\n      pattern: /(^[\\t ]*)#.*/m,\n      lookbehind: !0,\n      alias: "property",\n      inside: {\n        directive: {\n          pattern: /(#)\\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\\b/,\n          lookbehind: !0,\n          alias: "keyword"\n        }\n      }\n    }\n  });\n\n  var _ = $ + "|" + x,\n      B = a("/(?![*/])|//[^\\r\\n]*[\\r\\n]|/\\\\*(?:[^*]|\\\\*(?!/))*\\\\*/|<<0>>", [_]),\n      E = e(a("[^\\"\'/()]|<<0>>|\\\\(<<self>>*\\\\)", [B]), 2),\n      R = "\\\\b(?:assembly|event|field|method|module|param|property|return|type)\\\\b",\n      P = a("<<0>>(?:\\\\s*\\\\(<<1>>*\\\\))?", [m, E]);\n\n  s.languages.insertBefore("csharp", "class-name", {\n    attribute: {\n      pattern: t("((?:^|[^\\\\s\\\\w>)?])\\\\s*\\\\[\\\\s*)(?:<<0>>\\\\s*:\\\\s*)?<<1>>(?:\\\\s*,\\\\s*<<1>>)*(?=\\\\s*\\\\])", [R, P]),\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        target: {\n          pattern: t("^<<0>>(?=\\\\s*:)", [R]),\n          alias: "keyword"\n        },\n        "attribute-arguments": {\n          pattern: t("\\\\(<<0>>*\\\\)", [E]),\n          inside: s.languages.csharp\n        },\n        "class-name": {\n          pattern: RegExp(m),\n          inside: {\n            punctuation: /\\./\n          }\n        },\n        punctuation: /[:,]/\n      }\n    }\n  });\n  var z = ":[^}\\r\\n]+",\n      S = e(a("[^\\"\'/()]|<<0>>|\\\\(<<self>>*\\\\)", [B]), 2),\n      j = a("\\\\{(?!\\\\{)(?:(?![}:])<<0>>)*<<1>>?\\\\}", [S, z]),\n      A = e(a("[^\\"\'/()]|/(?!\\\\*)|/\\\\*(?:[^*]|\\\\*(?!/))*\\\\*/|<<0>>|\\\\(<<self>>*\\\\)", [_]), 2),\n      F = a("\\\\{(?!\\\\{)(?:(?![}:])<<0>>)*<<1>>?\\\\}", [A, z]);\n\n  function U(e, n) {\n    return {\n      interpolation: {\n        pattern: t("((?:^|[^{])(?:\\\\{\\\\{)*)<<0>>", [e]),\n        lookbehind: !0,\n        inside: {\n          "format-string": {\n            pattern: t("(^\\\\{(?:(?![}:])<<0>>)*)<<1>>(?=\\\\}$)", [n, z]),\n            lookbehind: !0,\n            inside: {\n              punctuation: /^:/\n            }\n          },\n          punctuation: /^\\{|\\}$/,\n          expression: {\n            pattern: /[\\s\\S]+/,\n            alias: "language-csharp",\n            inside: s.languages.csharp\n          }\n        }\n      },\n      string: /[\\s\\S]+/\n    };\n  }\n\n  s.languages.insertBefore("csharp", "string", {\n    "interpolation-string": [{\n      pattern: t(\'(^|[^\\\\\\\\])(?:\\\\$@|@\\\\$)"(?:""|\\\\\\\\[^]|\\\\{\\\\{|<<0>>|[^\\\\\\\\{"])*"\', [j]),\n      lookbehind: !0,\n      greedy: !0,\n      inside: U(j, S)\n    }, {\n      pattern: t(\'(^|[^@\\\\\\\\])\\\\$"(?:\\\\\\\\.|\\\\{\\\\{|<<0>>|[^\\\\\\\\"{])*"\', [F]),\n      lookbehind: !0,\n      greedy: !0,\n      inside: U(F, A)\n    }]\n  });\n}(Prism), Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;\n!function (e) {\n  var t = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/,\n      n = "\\\\b(?!<keyword>)\\\\w+(?:\\\\s*\\\\.\\\\s*\\\\w+)*\\\\b".replace(/<keyword>/g, function () {\n    return t.source;\n  });\n  e.languages.cpp = e.languages.extend("c", {\n    "class-name": [{\n      pattern: RegExp("(\\\\b(?:class|concept|enum|struct|typename)\\\\s+)(?!<keyword>)\\\\w+".replace(/<keyword>/g, function () {\n        return t.source;\n      })),\n      lookbehind: !0\n    }, /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/, /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i, /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],\n    keyword: t,\n    number: {\n      pattern: /(?:\\b0b[01\']+|\\b0x(?:[\\da-f\']+(?:\\.[\\da-f\']*)?|\\.[\\da-f\']+)(?:p[+-]?[\\d\']+)?|(?:\\b[\\d\']+(?:\\.[\\d\']*)?|\\B\\.[\\d\']+)(?:e[+-]?[\\d\']+)?)[ful]{0,4}/i,\n      greedy: !0\n    },\n    operator: />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n    boolean: /\\b(?:true|false)\\b/\n  }), e.languages.insertBefore("cpp", "string", {\n    module: {\n      pattern: RegExp(\'(\\\\b(?:module|import)\\\\s+)(?:"(?:\\\\\\\\(?:\\r\\n|[^])|[^"\\\\\\\\\\r\\n])*"|<[^<>\\r\\n]*>|\' + "<mod-name>(?:\\\\s*:\\\\s*<mod-name>)?|:\\\\s*<mod-name>".replace(/<mod-name>/g, function () {\n        return n;\n      }) + ")"),\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        string: /^[<"][\\s\\S]+/,\n        operator: /:/,\n        punctuation: /\\./\n      }\n    },\n    "raw-string": {\n      pattern: /R"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1"/,\n      alias: "string",\n      greedy: !0\n    }\n  }), e.languages.insertBefore("cpp", "keyword", {\n    "generic-function": {\n      pattern: /\\b[a-z_]\\w*\\s*<(?:[^<>]|<(?:[^<>])*>)*>(?=\\s*\\()/i,\n      inside: {\n        function: /^\\w+/,\n        generic: {\n          pattern: /<[\\s\\S]+/,\n          alias: "class-name",\n          inside: e.languages.cpp\n        }\n      }\n    }\n  }), e.languages.insertBefore("cpp", "operator", {\n    "double-colon": {\n      pattern: /::/,\n      alias: "punctuation"\n    }\n  }), e.languages.insertBefore("cpp", "class-name", {\n    "base-clause": {\n      pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}"\'\\s]+(?:\\s+[^;{}"\'\\s]+)*(?=\\s*[;{])/,\n      lookbehind: !0,\n      greedy: !0,\n      inside: e.languages.extend("cpp", {})\n    }\n  }), e.languages.insertBefore("inside", "double-colon", {\n    "class-name": /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n  }, e.languages.cpp["base-clause"]);\n}(Prism);\nPrism.languages.cmake = {\n  comment: /#.*/,\n  string: {\n    pattern: /"(?:[^\\\\"]|\\\\.)*"/,\n    greedy: !0,\n    inside: {\n      interpolation: {\n        pattern: /\\$\\{(?:[^{}$]|\\$\\{[^{}$]*\\})*\\}/,\n        inside: {\n          punctuation: /\\$\\{|\\}/,\n          variable: /\\w+/\n        }\n      }\n    }\n  },\n  variable: /\\b(?:CMAKE_\\w+|\\w+_(?:VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?|(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_(?:BINARY_DIR|DESCRIPTION|HOMEPAGE_URL|NAME|SOURCE_DIR|VERSION|VERSION_(?:MAJOR|MINOR|PATCH|TWEAK))|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE|XCODE_VERSION))\\b/,\n  property: /\\b(?:cxx_\\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\\w+|\\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|GLOBAL_KEYWORD|GLOBAL_PROJECT_TYPES|GLOBAL_ROOTNAMESPACE|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\\b/,\n  keyword: /\\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\\s*\\()\\b/,\n  boolean: /\\b(?:ON|OFF|TRUE|FALSE)\\b/,\n  namespace: /\\b(?:PROPERTIES|SHARED|PRIVATE|STATIC|PUBLIC|INTERFACE|TARGET_OBJECTS)\\b/,\n  operator: /\\b(?:NOT|AND|OR|MATCHES|LESS|GREATER|EQUAL|STRLESS|STRGREATER|STREQUAL|VERSION_LESS|VERSION_EQUAL|VERSION_GREATER|DEFINED)\\b/,\n  inserted: {\n    pattern: /\\b\\w+::\\w+\\b/,\n    alias: "class-name"\n  },\n  number: /\\b\\d+(?:\\.\\d+)*\\b/,\n  function: /\\b[a-z_]\\w*(?=\\s*\\()\\b/i,\n  punctuation: /[()>}]|\\$[<{]/\n};\n!function (e) {\n  var t = /#(?!\\{).+/,\n      n = {\n    pattern: /#\\{[^}]+\\}/,\n    alias: "variable"\n  };\n  e.languages.coffeescript = e.languages.extend("javascript", {\n    comment: t,\n    string: [{\n      pattern: /\'(?:\\\\[\\s\\S]|[^\\\\\'])*\'/,\n      greedy: !0\n    }, {\n      pattern: /"(?:\\\\[\\s\\S]|[^\\\\"])*"/,\n      greedy: !0,\n      inside: {\n        interpolation: n\n      }\n    }],\n    keyword: /\\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\\b/,\n    "class-member": {\n      pattern: /@(?!\\d)\\w+/,\n      alias: "variable"\n    }\n  }), e.languages.insertBefore("coffeescript", "comment", {\n    "multiline-comment": {\n      pattern: /###[\\s\\S]+?###/,\n      alias: "comment"\n    },\n    "block-regex": {\n      pattern: /\\/{3}[\\s\\S]*?\\/{3}/,\n      alias: "regex",\n      inside: {\n        comment: t,\n        interpolation: n\n      }\n    }\n  }), e.languages.insertBefore("coffeescript", "string", {\n    "inline-javascript": {\n      pattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n      inside: {\n        delimiter: {\n          pattern: /^`|`$/,\n          alias: "punctuation"\n        },\n        script: {\n          pattern: /[\\s\\S]+/,\n          alias: "language-javascript",\n          inside: e.languages.javascript\n        }\n      }\n    },\n    "multiline-string": [{\n      pattern: /\'\'\'[\\s\\S]*?\'\'\'/,\n      greedy: !0,\n      alias: "string"\n    }, {\n      pattern: /"""[\\s\\S]*?"""/,\n      greedy: !0,\n      alias: "string",\n      inside: {\n        interpolation: n\n      }\n    }]\n  }), e.languages.insertBefore("coffeescript", "keyword", {\n    property: /(?!\\d)\\w+(?=\\s*:(?!:))/\n  }), delete e.languages.coffeescript["template-string"], e.languages.coffee = e.languages.coffeescript;\n}(Prism);\nPrism.languages.csp = {\n  directive: {\n    pattern: /(^|[^-\\da-z])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[^-\\da-z]|$)/i,\n    lookbehind: !0,\n    alias: "keyword"\n  },\n  safe: {\n    pattern: /\'(?:deny|none|report-sample|self|strict-dynamic|top-only|(?:nonce|sha(?:256|384|512))-[-+/\\w=]+)\'/i,\n    alias: "selector"\n  },\n  unsafe: {\n    pattern: /(?:\'unsafe-(?:allow-redirects|dynamic|eval|hash-attributes|hashed-attributes|hashes|inline)\'|\\*)/i,\n    alias: "function"\n  }\n};\n!function (e) {\n  var a,\n      n = /("|\')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/;\n  e.languages.css.selector = {\n    pattern: e.languages.css.selector.pattern,\n    lookbehind: !0,\n    inside: a = {\n      "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n      "pseudo-class": /:[-\\w]+/,\n      class: /\\.[-\\w]+/,\n      id: /#[-\\w]+/,\n      attribute: {\n        pattern: RegExp("\\\\[(?:[^[\\\\]\\"\']|" + n.source + ")*\\\\]"),\n        greedy: !0,\n        inside: {\n          punctuation: /^\\[|\\]$/,\n          "case-sensitivity": {\n            pattern: /(\\s)[si]$/i,\n            lookbehind: !0,\n            alias: "keyword"\n          },\n          namespace: {\n            pattern: /^(\\s*)(?:(?!\\s)[-*\\w\\xA0-\\uFFFF])*\\|(?!=)/,\n            lookbehind: !0,\n            inside: {\n              punctuation: /\\|$/\n            }\n          },\n          "attr-name": {\n            pattern: /^(\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+/,\n            lookbehind: !0\n          },\n          "attr-value": [n, {\n            pattern: /(=\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+(?=\\s*$)/,\n            lookbehind: !0\n          }],\n          operator: /[|~*^$]?=/\n        }\n      },\n      "n-th": [{\n        pattern: /(\\(\\s*)[+-]?\\d*[\\dn](?:\\s*[+-]\\s*\\d+)?(?=\\s*\\))/,\n        lookbehind: !0,\n        inside: {\n          number: /[\\dn]+/,\n          operator: /[+-]/\n        }\n      }, {\n        pattern: /(\\(\\s*)(?:even|odd)(?=\\s*\\))/i,\n        lookbehind: !0\n      }],\n      combinator: />|\\+|~|\\|\\|/,\n      punctuation: /[(),]/\n    }\n  }, e.languages.css.atrule.inside["selector-function-argument"].inside = a, e.languages.insertBefore("css", "property", {\n    variable: {\n      pattern: /(^|[^-\\w\\xA0-\\uFFFF])--(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*/i,\n      lookbehind: !0\n    }\n  });\n  var r = {\n    pattern: /(\\b\\d+)(?:%|[a-z]+(?![\\w-]))/,\n    lookbehind: !0\n  },\n      i = {\n    pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n    lookbehind: !0\n  };\n  e.languages.insertBefore("css", "function", {\n    operator: {\n      pattern: /(\\s)[+\\-*\\/](?=\\s)/,\n      lookbehind: !0\n    },\n    hexcode: {\n      pattern: /\\B#[\\da-f]{3,8}\\b/i,\n      alias: "color"\n    },\n    color: [{\n      pattern: /(^|[^\\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\\w-])/i,\n      lookbehind: !0\n    }, {\n      pattern: /\\b(?:rgb|hsl)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:rgb|hsl)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n      inside: {\n        unit: r,\n        number: i,\n        function: /[\\w-]+(?=\\()/,\n        punctuation: /[(),]/\n      }\n    }],\n    entity: /\\\\[\\da-f]{1,8}/i,\n    unit: r,\n    number: i\n  });\n}(Prism);\n!function (i) {\n  i.languages.diff = {\n    coord: [/^(?:\\*{3}|-{3}|\\+{3}).*$/m, /^@@.*@@$/m, /^\\d.*$/m]\n  };\n  var r = {\n    "deleted-sign": "-",\n    "deleted-arrow": "<",\n    "inserted-sign": "+",\n    "inserted-arrow": ">",\n    unchanged: " ",\n    diff: "!"\n  };\n  Object.keys(r).forEach(function (e) {\n    var n = r[e],\n        a = [];\n    /^\\w+$/.test(e) || a.push(/\\w+/.exec(e)[0]), "diff" === e && a.push("bold"), i.languages.diff[e] = {\n      pattern: RegExp("^(?:[" + n + "].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+", "m"),\n      alias: a,\n      inside: {\n        line: {\n          pattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n          lookbehind: !0\n        },\n        prefix: {\n          pattern: /[\\s\\S]/,\n          alias: /\\w+/.exec(e)[0]\n        }\n      }\n    };\n  }), Object.defineProperty(i.languages.diff, "PREFIXES", {\n    value: r\n  });\n}(Prism);\n!function (h) {\n  function v(e, n) {\n    return "___" + e.toUpperCase() + n + "___";\n  }\n\n  Object.defineProperties(h.languages["markup-templating"] = {}, {\n    buildPlaceholders: {\n      value: function value(a, r, e, o) {\n        if (a.language === r) {\n          var c = a.tokenStack = [];\n          a.code = a.code.replace(e, function (e) {\n            if ("function" == typeof o && !o(e)) return e;\n\n            for (var n, t = c.length; -1 !== a.code.indexOf(n = v(r, t));) {\n              ++t;\n            }\n\n            return c[t] = e, n;\n          }), a.grammar = h.languages.markup;\n        }\n      }\n    },\n    tokenizePlaceholders: {\n      value: function value(p, k) {\n        if (p.language === k && p.tokenStack) {\n          p.grammar = h.languages[k];\n          var m = 0,\n              d = Object.keys(p.tokenStack);\n          !function e(n) {\n            for (var t = 0; t < n.length && !(m >= d.length); t++) {\n              var a = n[t];\n\n              if ("string" == typeof a || a.content && "string" == typeof a.content) {\n                var r = d[m],\n                    o = p.tokenStack[r],\n                    c = "string" == typeof a ? a : a.content,\n                    i = v(k, r),\n                    u = c.indexOf(i);\n\n                if (-1 < u) {\n                  ++m;\n                  var g = c.substring(0, u),\n                      l = new h.Token(k, h.tokenize(o, p.grammar), "language-" + k, o),\n                      s = c.substring(u + i.length),\n                      f = [];\n                  g && f.push.apply(f, e([g])), f.push(l), s && f.push.apply(f, e([s])), "string" == typeof a ? n.splice.apply(n, [t, 1].concat(f)) : a.content = f;\n                }\n              } else a.content && e(a.content);\n            }\n\n            return n;\n          }(p.tokens);\n        }\n      }\n    }\n  });\n}(Prism);\n!function (e) {\n  e.languages.django = {\n    comment: /^\\{#[\\s\\S]*?#\\}$/,\n    tag: {\n      pattern: /(^\\{%[+-]?\\s*)\\w+/,\n      lookbehind: !0,\n      alias: "keyword"\n    },\n    delimiter: {\n      pattern: /^\\{[{%][+-]?|[+-]?[}%]\\}$/,\n      alias: "punctuation"\n    },\n    string: {\n      pattern: /("|\')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n      greedy: !0\n    },\n    filter: {\n      pattern: /(\\|)\\w+/,\n      lookbehind: !0,\n      alias: "function"\n    },\n    test: {\n      pattern: /(\\bis\\s+(?:not\\s+)?)(?!not\\b)\\w+/,\n      lookbehind: !0,\n      alias: "function"\n    },\n    function: /\\b[a-z_]\\w+(?=\\s*\\()/i,\n    keyword: /\\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\\b/,\n    operator: /[-+%=]=?|!=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n    number: /\\b\\d+(?:\\.\\d+)?\\b/,\n    boolean: /[Tt]rue|[Ff]alse|[Nn]one/,\n    variable: /\\b\\w+?\\b/,\n    punctuation: /[{}[\\](),.:;]/\n  };\n  var n = /\\{\\{[\\s\\S]*?\\}\\}|\\{%[\\s\\S]*?%\\}|\\{#[\\s\\S]*?#\\}/g,\n      o = e.languages["markup-templating"];\n  e.hooks.add("before-tokenize", function (e) {\n    o.buildPlaceholders(e, "django", n);\n  }), e.hooks.add("after-tokenize", function (e) {\n    o.tokenizePlaceholders(e, "django");\n  }), e.languages.jinja2 = e.languages.django, e.hooks.add("before-tokenize", function (e) {\n    o.buildPlaceholders(e, "jinja2", n);\n  }), e.hooks.add("after-tokenize", function (e) {\n    o.tokenizePlaceholders(e, "jinja2");\n  });\n}(Prism);\n!function (e) {\n  var r = "(?:[ \\t]+(?![ \\t])(?:<SP_BS>)?|<SP_BS>)".replace(/<SP_BS>/g, function () {\n    return "\\\\\\\\[\\r\\n](?:\\\\s|\\\\\\\\[\\r\\n]|#.*(?!.))*(?![\\\\s#]|\\\\\\\\[\\r\\n])";\n  }),\n      n = "\\"(?:[^\\"\\\\\\\\\\r\\n]|\\\\\\\\(?:\\r\\n|[^]))*\\"|\'(?:[^\'\\\\\\\\\\r\\n]|\\\\\\\\(?:\\r\\n|[^]))*\'",\n      t = "--[\\\\w-]+=(?:<STR>|(?![\\"\'])(?:[^\\\\s\\\\\\\\]|\\\\\\\\.)+)".replace(/<STR>/g, function () {\n    return n;\n  }),\n      o = {\n    pattern: RegExp(n),\n    greedy: !0\n  },\n      i = {\n    pattern: /(^[ \\t]*)#.*/m,\n    lookbehind: !0,\n    greedy: !0\n  };\n\n  function a(e, n) {\n    return e = e.replace(/<OPT>/g, function () {\n      return t;\n    }).replace(/<SP>/g, function () {\n      return r;\n    }), RegExp(e, n);\n  }\n\n  e.languages.docker = {\n    instruction: {\n      pattern: /(^[ \\t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\\s)(?:\\\\.|[^\\r\\n\\\\])*(?:\\\\$(?:\\s|#.*$)*(?![\\s#])(?:\\\\.|[^\\r\\n\\\\])*)*/im,\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        options: {\n          pattern: a("(^(?:ONBUILD<SP>)?\\\\w+<SP>)<OPT>(?:<SP><OPT>)*", "i"),\n          lookbehind: !0,\n          greedy: !0,\n          inside: {\n            property: {\n              pattern: /(^|\\s)--[\\w-]+/,\n              lookbehind: !0\n            },\n            string: [o, {\n              pattern: /(=)(?!["\'])(?:[^\\s\\\\]|\\\\.)+/,\n              lookbehind: !0\n            }],\n            operator: /\\\\$/m,\n            punctuation: /=/\n          }\n        },\n        keyword: [{\n          pattern: a("(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\\\\b", "i"),\n          lookbehind: !0,\n          greedy: !0\n        }, {\n          pattern: a("(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \\t\\\\\\\\]+<SP>)AS", "i"),\n          lookbehind: !0,\n          greedy: !0\n        }, {\n          pattern: a("(^ONBUILD<SP>)\\\\w+", "i"),\n          lookbehind: !0,\n          greedy: !0\n        }, {\n          pattern: /^\\w+/,\n          greedy: !0\n        }],\n        comment: i,\n        string: o,\n        variable: /\\$(?:\\w+|\\{[^{}"\'\\\\]*\\})/,\n        operator: /\\\\$/m\n      }\n    },\n    comment: i\n  }, e.languages.dockerfile = e.languages.docker;\n}(Prism);\nPrism.languages.elixir = {\n  doc: {\n    pattern: /@(?:doc|moduledoc)\\s+(?:("""|\'\'\')[\\s\\S]*?\\1|("|\')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2)/,\n    inside: {\n      attribute: /^@\\w+/,\n      string: /[\'"][\\s\\S]+/\n    }\n  },\n  comment: {\n    pattern: /#.*/m,\n    greedy: !0\n  },\n  regex: {\n    pattern: /~[rR](?:("""|\'\'\')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1|([\\/|"\'])(?:\\\\.|(?!\\2)[^\\\\\\r\\n])+\\2|\\((?:\\\\.|[^\\\\)\\r\\n])+\\)|\\[(?:\\\\.|[^\\\\\\]\\r\\n])+\\]|\\{(?:\\\\.|[^\\\\}\\r\\n])+\\}|<(?:\\\\.|[^\\\\>\\r\\n])+>)[uismxfr]*/,\n    greedy: !0\n  },\n  string: [{\n    pattern: /~[cCsSwW](?:("""|\'\'\')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1|([\\/|"\'])(?:\\\\.|(?!\\2)[^\\\\\\r\\n])+\\2|\\((?:\\\\.|[^\\\\)\\r\\n])+\\)|\\[(?:\\\\.|[^\\\\\\]\\r\\n])+\\]|\\{(?:\\\\.|#\\{[^}]+\\}|#(?!\\{)|[^#\\\\}\\r\\n])+\\}|<(?:\\\\.|[^\\\\>\\r\\n])+>)[csa]?/,\n    greedy: !0,\n    inside: {}\n  }, {\n    pattern: /("""|\'\'\')[\\s\\S]*?\\1/,\n    greedy: !0,\n    inside: {}\n  }, {\n    pattern: /("|\')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: !0,\n    inside: {}\n  }],\n  atom: {\n    pattern: /(^|[^:]):\\w+/,\n    lookbehind: !0,\n    alias: "symbol"\n  },\n  module: {\n    pattern: /\\b[A-Z]\\w*\\b/,\n    alias: "class-name"\n  },\n  "attr-name": /\\b\\w+\\??:(?!:)/,\n  argument: {\n    pattern: /(^|[^&])&\\d+/,\n    lookbehind: !0,\n    alias: "variable"\n  },\n  attribute: {\n    pattern: /@\\w+/,\n    alias: "variable"\n  },\n  function: /\\b[_a-zA-Z]\\w*[?!]?(?:(?=\\s*(?:\\.\\s*)?\\()|(?=\\/\\d))/,\n  number: /\\b(?:0[box][a-f\\d_]+|\\d[\\d_]*)(?:\\.[\\d_]+)?(?:e[+-]?[\\d_]+)?\\b/i,\n  keyword: /\\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\\b/,\n  boolean: /\\b(?:true|false|nil)\\b/,\n  operator: [/\\bin\\b|&&?|\\|[|>]?|\\\\\\\\|::|\\.\\.\\.?|\\+\\+?|-[->]?|<[-=>]|>=|!==?|\\B!|=(?:==?|[>~])?|[*\\/^]/, {\n    pattern: /([^<])<(?!<)/,\n    lookbehind: !0\n  }, {\n    pattern: /([^>])>(?!>)/,\n    lookbehind: !0\n  }],\n  punctuation: /<<|>>|[.,%\\[\\]{}()]/\n}, Prism.languages.elixir.string.forEach(function (e) {\n  e.inside = {\n    interpolation: {\n      pattern: /#\\{[^}]+\\}/,\n      inside: {\n        delimiter: {\n          pattern: /^#\\{|\\}$/,\n          alias: "punctuation"\n        },\n        rest: Prism.languages.elixir\n      }\n    }\n  };\n});\nPrism.languages.elm = {\n  comment: /--.*|\\{-[\\s\\S]*?-\\}/,\n  char: {\n    pattern: /\'(?:[^\\\\\'\\r\\n]|\\\\(?:[abfnrtv\\\\\']|\\d+|x[0-9a-fA-F]+))\'/,\n    greedy: !0\n  },\n  string: [{\n    pattern: /"""[\\s\\S]*?"""/,\n    greedy: !0\n  }, {\n    pattern: /"(?:[^\\\\"\\r\\n]|\\\\.)*"/,\n    greedy: !0\n  }],\n  "import-statement": {\n    pattern: /(^[\\t ]*)import\\s+[A-Z]\\w*(?:\\.[A-Z]\\w*)*(?:\\s+as\\s+(?:[A-Z]\\w*)(?:\\.[A-Z]\\w*)*)?(?:\\s+exposing\\s+)?/m,\n    lookbehind: !0,\n    inside: {\n      keyword: /\\b(?:import|as|exposing)\\b/\n    }\n  },\n  keyword: /\\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\\b/,\n  builtin: /\\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\\b/,\n  number: /\\b(?:\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?|0x[0-9a-f]+)\\b/i,\n  operator: /\\s\\.\\s|[+\\-/*=.$<>:&|^?%#@~!]{2,}|[+\\-/*=$<>:&|^?%#@~!]/,\n  hvariable: /\\b(?:[A-Z]\\w*\\.)*[a-z]\\w*\\b/,\n  constant: /\\b(?:[A-Z]\\w*\\.)*[A-Z]\\w*\\b/,\n  punctuation: /[{}[\\]|(),.:]/\n};\nPrism.languages.erlang = {\n  comment: /%.+/,\n  string: {\n    pattern: /"(?:\\\\.|[^\\\\"\\r\\n])*"/,\n    greedy: !0\n  },\n  "quoted-function": {\n    pattern: /\'(?:\\\\.|[^\\\\\'\\r\\n])+\'(?=\\()/,\n    alias: "function"\n  },\n  "quoted-atom": {\n    pattern: /\'(?:\\\\.|[^\\\\\'\\r\\n])+\'/,\n    alias: "atom"\n  },\n  boolean: /\\b(?:true|false)\\b/,\n  keyword: /\\b(?:fun|when|case|of|end|if|receive|after|try|catch)\\b/,\n  number: [/\\$\\\\?./, /\\b\\d+#[a-z0-9]+/i, /(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i],\n  function: /\\b[a-z][\\w@]*(?=\\()/,\n  variable: {\n    pattern: /(^|[^@])(?:\\b|\\?)[A-Z_][\\w@]*/,\n    lookbehind: !0\n  },\n  operator: [/[=\\/<>:]=|=[:\\/]=|\\+\\+?|--?|[=*\\/!]|\\b(?:bnot|div|rem|band|bor|bxor|bsl|bsr|not|and|or|xor|orelse|andalso)\\b/, {\n    pattern: /(^|[^<])<(?!<)/,\n    lookbehind: !0\n  }, {\n    pattern: /(^|[^>])>(?!>)/,\n    lookbehind: !0\n  }],\n  atom: /\\b[a-z][\\w@]*/,\n  punctuation: /[()[\\]{}:;,.#|]|<<|>>/\n};\nPrism.languages.fsharp = Prism.languages.extend("clike", {\n  comment: [{\n    pattern: /(^|[^\\\\])\\(\\*(?!\\))[\\s\\S]*?\\*\\)/,\n    lookbehind: !0\n  }, {\n    pattern: /(^|[^\\\\:])\\/\\/.*/,\n    lookbehind: !0\n  }],\n  string: {\n    pattern: /(?:"""[\\s\\S]*?"""|@"(?:""|[^"])*"|"(?:\\\\[\\s\\S]|[^\\\\"])*")B?|\'(?:[^\\\\\']|\\\\(?:.|\\d{3}|x[a-fA-F\\d]{2}|u[a-fA-F\\d]{4}|U[a-fA-F\\d]{8}))\'B?/,\n    greedy: !0\n  },\n  "class-name": {\n    pattern: /(\\b(?:exception|inherit|interface|new|of|type)\\s+|\\w\\s*:\\s*|\\s:\\??>\\s*)[.\\w]+\\b(?:\\s*(?:->|\\*)\\s*[.\\w]+\\b)*(?!\\s*[:.])/,\n    lookbehind: !0,\n    inside: {\n      operator: /->|\\*/,\n      punctuation: /\\./\n    }\n  },\n  keyword: /\\b(?:let|return|use|yield)(?:!\\B|\\b)|\\b(?:abstract|and|as|assert|base|begin|class|default|delegate|do|done|downcast|downto|elif|else|end|exception|extern|false|finally|for|fun|function|global|if|in|inherit|inline|interface|internal|lazy|match|member|module|mutable|namespace|new|not|null|of|open|or|override|private|public|rec|select|static|struct|then|to|true|try|type|upcast|val|void|when|while|with|asr|land|lor|lsl|lsr|lxor|mod|sig|atomic|break|checked|component|const|constraint|constructor|continue|eager|event|external|fixed|functor|include|method|mixin|object|parallel|process|protected|pure|sealed|tailcall|trait|virtual|volatile)\\b/,\n  number: [/\\b0x[\\da-fA-F]+(?:un|lf|LF)?\\b/, /\\b0b[01]+(?:y|uy)?\\b/, /(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[fm]|e[+-]?\\d+)?\\b/i, /\\b\\d+(?:[IlLsy]|u[lsy]?|UL)?\\b/],\n  operator: /([<>~&^])\\1\\1|([*.:<>&])\\2|<-|->|[!=:]=|<?\\|{1,3}>?|\\??(?:<=|>=|<>|[-+*/%=<>])\\??|[!?^&]|~[+~-]|:>|:\\?>?/\n}), Prism.languages.insertBefore("fsharp", "keyword", {\n  preprocessor: {\n    pattern: /(^[\\t ]*)#.*/m,\n    lookbehind: !0,\n    alias: "property",\n    inside: {\n      directive: {\n        pattern: /(^#)\\b(?:else|endif|if|light|line|nowarn)\\b/,\n        lookbehind: !0,\n        alias: "keyword"\n      }\n    }\n  }\n}), Prism.languages.insertBefore("fsharp", "punctuation", {\n  "computation-expression": {\n    pattern: /\\b[_a-z]\\w*(?=\\s*\\{)/i,\n    alias: "keyword"\n  }\n}), Prism.languages.insertBefore("fsharp", "string", {\n  annotation: {\n    pattern: /\\[<.+?>\\]/,\n    inside: {\n      punctuation: /^\\[<|>\\]$/,\n      "class-name": {\n        pattern: /^\\w+$|(^|;\\s*)[A-Z]\\w*(?=\\()/,\n        lookbehind: !0\n      },\n      "annotation-content": {\n        pattern: /[\\s\\S]+/,\n        inside: Prism.languages.fsharp\n      }\n    }\n  }\n});\n!function (a) {\n  a.languages.flow = a.languages.extend("javascript", {}), a.languages.insertBefore("flow", "keyword", {\n    type: [{\n      pattern: /\\b(?:[Nn]umber|[Ss]tring|[Bb]oolean|Function|any|mixed|null|void)\\b/,\n      alias: "tag"\n    }]\n  }), a.languages.flow["function-variable"].pattern = /(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=\\s*(?:function\\b|(?:\\([^()]*\\)(?:\\s*:\\s*\\w+)?|(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/i, delete a.languages.flow.parameter, a.languages.insertBefore("flow", "operator", {\n    "flow-punctuation": {\n      pattern: /\\{\\||\\|\\}/,\n      alias: "punctuation"\n    }\n  }), Array.isArray(a.languages.flow.keyword) || (a.languages.flow.keyword = [a.languages.flow.keyword]), a.languages.flow.keyword.unshift({\n    pattern: /(^|[^$]\\b)(?:type|opaque|declare|Class)\\b(?!\\$)/,\n    lookbehind: !0\n  }, {\n    pattern: /(^|[^$]\\B)\\$(?:await|Diff|Exact|Keys|ObjMap|PropertyType|Shape|Record|Supertype|Subtype|Enum)\\b(?!\\$)/,\n    lookbehind: !0\n  });\n}(Prism);\nPrism.languages.git = {\n  comment: /^#.*/m,\n  deleted: /^[-–].*/m,\n  inserted: /^\\+.*/m,\n  string: /("|\')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/m,\n  command: {\n    pattern: /^.*\\$ git .*$/m,\n    inside: {\n      parameter: /\\s--?\\w+/m\n    }\n  },\n  coord: /^@@.*@@$/m,\n  "commit-sha1": /^commit \\w{40}$/m\n};\nPrism.languages.go = Prism.languages.extend("clike", {\n  string: {\n    pattern: /(["\'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1/,\n    greedy: !0\n  },\n  keyword: /\\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,\n  boolean: /\\b(?:_|iota|nil|true|false)\\b/,\n  number: /(?:\\b0x[a-f\\d]+|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[-+]?\\d+)?)i?/i,\n  operator: /[*\\/%^!=]=?|\\+[=+]?|-[=-]?|\\|[=|]?|&(?:=|&|\\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\\.\\.\\./,\n  builtin: /\\b(?:bool|byte|complex(?:64|128)|error|float(?:32|64)|rune|string|u?int(?:8|16|32|64)?|uintptr|append|cap|close|complex|copy|delete|imag|len|make|new|panic|print(?:ln)?|real|recover)\\b/\n}), delete Prism.languages.go["class-name"];\nPrism.languages.graphql = {\n  comment: /#.*/,\n  description: {\n    pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\\\.|[^\\\\"\\r\\n])*")(?=\\s*[a-z_])/i,\n    greedy: !0,\n    alias: "string",\n    inside: {\n      "language-markdown": {\n        pattern: /(^"(?:"")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: !0,\n        inside: Prism.languages.markdown\n      }\n    }\n  },\n  string: {\n    pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\\\.|[^\\\\"\\r\\n])*"/,\n    greedy: !0\n  },\n  number: /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  boolean: /\\b(?:true|false)\\b/,\n  variable: /\\$[a-z_]\\w*/i,\n  directive: {\n    pattern: /@[a-z_]\\w*/i,\n    alias: "function"\n  },\n  "attr-name": {\n    pattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()"]|"(?:\\\\.|[^\\\\"\\r\\n])*")*\\))?:)/i,\n    greedy: !0\n  },\n  "atom-input": {\n    pattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n    alias: "class-name"\n  },\n  scalar: /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  constant: /\\b[A-Z][A-Z_\\d]*\\b/,\n  "class-name": {\n    pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: !0\n  },\n  fragment: {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: !0,\n    alias: "function"\n  },\n  "definition-mutation": {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: !0,\n    alias: "function"\n  },\n  "definition-query": {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: !0,\n    alias: "function"\n  },\n  keyword: /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  operator: /[!=|&]|\\.{3}/,\n  "property-query": /\\w+(?=\\s*\\()/,\n  object: /\\w+(?=\\s*\\{)/,\n  punctuation: /[!(){}\\[\\]:=,]/,\n  property: /\\w+/\n}, Prism.hooks.add("after-tokenize", function (n) {\n  if ("graphql" === n.language) for (var o = n.tokens.filter(function (n) {\n    return "string" != typeof n && "comment" !== n.type && "scalar" !== n.type;\n  }), s = 0; s < o.length;) {\n    var t = o[s++];\n\n    if ("keyword" === t.type && "mutation" === t.content) {\n      var e = [];\n\n      if (c(["definition-mutation", "punctuation"]) && "(" === l(1).content) {\n        s += 2;\n        var a = f(/^\\($/, /^\\)$/);\n        if (-1 === a) continue;\n\n        for (; s < a; s++) {\n          var r = l(0);\n          "variable" === r.type && (m(r, "variable-input"), e.push(r.content));\n        }\n\n        s = a + 1;\n      }\n\n      if (c(["punctuation", "property-query"]) && "{" === l(0).content && (s++, m(l(0), "property-mutation"), 0 < e.length)) {\n        var i = f(/^\\{$/, /^\\}$/);\n        if (-1 === i) continue;\n\n        for (var u = s; u < i; u++) {\n          var p = o[u];\n          "variable" === p.type && 0 <= e.indexOf(p.content) && m(p, "variable-input");\n        }\n      }\n    }\n  }\n\n  function l(n) {\n    return o[s + n];\n  }\n\n  function c(n, t) {\n    t = t || 0;\n\n    for (var e = 0; e < n.length; e++) {\n      var a = l(e + t);\n      if (!a || a.type !== n[e]) return !1;\n    }\n\n    return !0;\n  }\n\n  function f(n, t) {\n    for (var e = 1, a = s; a < o.length; a++) {\n      var r = o[a],\n          i = r.content;\n      if ("punctuation" === r.type && "string" == typeof i) if (n.test(i)) e++;else if (t.test(i) && 0 === --e) return a;\n    }\n\n    return -1;\n  }\n\n  function m(n, t) {\n    var e = n.alias;\n    e ? Array.isArray(e) || (n.alias = e = [e]) : n.alias = e = [], e.push(t);\n  }\n});\n!function (e) {\n  e.languages.ruby = e.languages.extend("clike", {\n    comment: [/#.*/, {\n      pattern: /^=begin\\s[\\s\\S]*?^=end/m,\n      greedy: !0\n    }],\n    "class-name": {\n      pattern: /(\\b(?:class)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n      lookbehind: !0,\n      inside: {\n        punctuation: /[.\\\\]/\n      }\n    },\n    keyword: /\\b(?:alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|protected|private|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\\b/\n  });\n  var n = {\n    pattern: /#\\{[^}]+\\}/,\n    inside: {\n      delimiter: {\n        pattern: /^#\\{|\\}$/,\n        alias: "tag"\n      },\n      rest: e.languages.ruby\n    }\n  };\n  delete e.languages.ruby.function, e.languages.insertBefore("ruby", "keyword", {\n    regex: [{\n      pattern: RegExp("%r(?:" + ["([^a-zA-Z0-9\\\\s{(\\\\[<])(?:(?!\\\\1)[^\\\\\\\\]|\\\\\\\\[^])*\\\\1", "\\\\((?:[^()\\\\\\\\]|\\\\\\\\[^])*\\\\)", "\\\\{(?:[^#{}\\\\\\\\]|#(?:\\\\{[^}]+\\\\})?|\\\\\\\\[^])*\\\\}", "\\\\[(?:[^\\\\[\\\\]\\\\\\\\]|\\\\\\\\[^])*\\\\]", "<(?:[^<>\\\\\\\\]|\\\\\\\\[^])*>"].join("|") + ")[egimnosux]{0,6}"),\n      greedy: !0,\n      inside: {\n        interpolation: n\n      }\n    }, {\n      pattern: /(^|[^/])\\/(?!\\/)(?:\\[[^\\r\\n\\]]+\\]|\\\\.|[^[/\\\\\\r\\n])+\\/[egimnosux]{0,6}(?=\\s*(?:$|[\\r\\n,.;})#]))/,\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        interpolation: n\n      }\n    }],\n    variable: /[@$]+[a-zA-Z_]\\w*(?:[?!]|\\b)/,\n    symbol: {\n      pattern: /(^|[^:]):[a-zA-Z_]\\w*(?:[?!]|\\b)/,\n      lookbehind: !0\n    },\n    "method-definition": {\n      pattern: /(\\bdef\\s+)[\\w.]+/,\n      lookbehind: !0,\n      inside: {\n        function: /\\w+$/,\n        rest: e.languages.ruby\n      }\n    }\n  }), e.languages.insertBefore("ruby", "number", {\n    builtin: /\\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|Fixnum|Float|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\\b/,\n    constant: /\\b[A-Z]\\w*(?:[?!]|\\b)/\n  }), e.languages.ruby.string = [{\n    pattern: RegExp("%[qQiIwWxs]?(?:" + ["([^a-zA-Z0-9\\\\s{(\\\\[<])(?:(?!\\\\1)[^\\\\\\\\]|\\\\\\\\[^])*\\\\1", "\\\\((?:[^()\\\\\\\\]|\\\\\\\\[^])*\\\\)", "\\\\{(?:[^#{}\\\\\\\\]|#(?:\\\\{[^}]+\\\\})?|\\\\\\\\[^])*\\\\}", "\\\\[(?:[^\\\\[\\\\]\\\\\\\\]|\\\\\\\\[^])*\\\\]", "<(?:[^<>\\\\\\\\]|\\\\\\\\[^])*>"].join("|") + ")"),\n    greedy: !0,\n    inside: {\n      interpolation: n\n    }\n  }, {\n    pattern: /("|\')(?:#\\{[^}]+\\}|#(?!\\{)|\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\#\\r\\n])*\\1/,\n    greedy: !0,\n    inside: {\n      interpolation: n\n    }\n  }, {\n    pattern: /<<[-~]?([a-z_]\\w*)[\\r\\n](?:.*[\\r\\n])*?[\\t ]*\\1/i,\n    alias: "heredoc-string",\n    greedy: !0,\n    inside: {\n      delimiter: {\n        pattern: /^<<[-~]?[a-z_]\\w*|[a-z_]\\w*$/i,\n        alias: "symbol",\n        inside: {\n          punctuation: /^<<[-~]?/\n        }\n      },\n      interpolation: n\n    }\n  }, {\n    pattern: /<<[-~]?\'([a-z_]\\w*)\'[\\r\\n](?:.*[\\r\\n])*?[\\t ]*\\1/i,\n    alias: "heredoc-string",\n    greedy: !0,\n    inside: {\n      delimiter: {\n        pattern: /^<<[-~]?\'[a-z_]\\w*\'|[a-z_]\\w*$/i,\n        alias: "symbol",\n        inside: {\n          punctuation: /^<<[-~]?\'|\'$/\n        }\n      }\n    }\n  }], e.languages.rb = e.languages.ruby;\n}(Prism);\n!function (e) {\n  e.languages.haml = {\n    "multiline-comment": {\n      pattern: /((?:^|\\r?\\n|\\r)([\\t ]*))(?:\\/|-#).*(?:(?:\\r?\\n|\\r)\\2[\\t ].+)*/,\n      lookbehind: !0,\n      alias: "comment"\n    },\n    "multiline-code": [{\n      pattern: /((?:^|\\r?\\n|\\r)([\\t ]*)(?:[~-]|[&!]?=)).*,[\\t ]*(?:(?:\\r?\\n|\\r)\\2[\\t ].*,[\\t ]*)*(?:(?:\\r?\\n|\\r)\\2[\\t ].+)/,\n      lookbehind: !0,\n      inside: e.languages.ruby\n    }, {\n      pattern: /((?:^|\\r?\\n|\\r)([\\t ]*)(?:[~-]|[&!]?=)).*\\|[\\t ]*(?:(?:\\r?\\n|\\r)\\2[\\t ].*\\|[\\t ]*)*/,\n      lookbehind: !0,\n      inside: e.languages.ruby\n    }],\n    filter: {\n      pattern: /((?:^|\\r?\\n|\\r)([\\t ]*)):[\\w-]+(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+/,\n      lookbehind: !0,\n      inside: {\n        "filter-name": {\n          pattern: /^:[\\w-]+/,\n          alias: "variable"\n        }\n      }\n    },\n    markup: {\n      pattern: /((?:^|\\r?\\n|\\r)[\\t ]*)<.+/,\n      lookbehind: !0,\n      inside: e.languages.markup\n    },\n    doctype: {\n      pattern: /((?:^|\\r?\\n|\\r)[\\t ]*)!!!(?: .+)?/,\n      lookbehind: !0\n    },\n    tag: {\n      pattern: /((?:^|\\r?\\n|\\r)[\\t ]*)[%.#][\\w\\-#.]*[\\w\\-](?:\\([^)]+\\)|\\{(?:\\{[^}]+\\}|[^{}])+\\}|\\[[^\\]]+\\])*[\\/<>]*/,\n      lookbehind: !0,\n      inside: {\n        attributes: [{\n          pattern: /(^|[^#])\\{(?:\\{[^}]+\\}|[^{}])+\\}/,\n          lookbehind: !0,\n          inside: e.languages.ruby\n        }, {\n          pattern: /\\([^)]+\\)/,\n          inside: {\n            "attr-value": {\n              pattern: /(=\\s*)(?:"(?:\\\\.|[^\\\\"\\r\\n])*"|[^)\\s]+)/,\n              lookbehind: !0\n            },\n            "attr-name": /[\\w:-]+(?=\\s*!?=|\\s*[,)])/,\n            punctuation: /[=(),]/\n          }\n        }, {\n          pattern: /\\[[^\\]]+\\]/,\n          inside: e.languages.ruby\n        }],\n        punctuation: /[<>]/\n      }\n    },\n    code: {\n      pattern: /((?:^|\\r?\\n|\\r)[\\t ]*(?:[~-]|[&!]?=)).+/,\n      lookbehind: !0,\n      inside: e.languages.ruby\n    },\n    interpolation: {\n      pattern: /#\\{[^}]+\\}/,\n      inside: {\n        delimiter: {\n          pattern: /^#\\{|\\}$/,\n          alias: "punctuation"\n        },\n        rest: e.languages.ruby\n      }\n    },\n    punctuation: {\n      pattern: /((?:^|\\r?\\n|\\r)[\\t ]*)[~=\\-&!]+/,\n      lookbehind: !0\n    }\n  };\n\n  for (var t = ["css", {\n    filter: "coffee",\n    language: "coffeescript"\n  }, "erb", "javascript", "less", "markdown", "ruby", "scss", "textile"], n = {}, r = 0, a = t.length; r < a; r++) {\n    var i = t[r];\n    i = "string" == typeof i ? {\n      filter: i,\n      language: i\n    } : i, e.languages[i.language] && (n["filter-" + i.filter] = {\n      pattern: RegExp("((?:^|\\\\r?\\\\n|\\\\r)([\\\\t ]*)):{{filter_name}}(?:(?:\\\\r?\\\\n|\\\\r)(?:\\\\2[\\\\t ].+|\\\\s*?(?=\\\\r?\\\\n|\\\\r)))+".replace("{{filter_name}}", function () {\n        return i.filter;\n      })),\n      lookbehind: !0,\n      inside: {\n        "filter-name": {\n          pattern: /^:[\\w-]+/,\n          alias: "variable"\n        },\n        rest: e.languages[i.language]\n      }\n    });\n  }\n\n  e.languages.insertBefore("haml", "filter", n);\n}(Prism);\n!function (e) {\n  e.languages.handlebars = {\n    comment: /\\{\\{![\\s\\S]*?\\}\\}/,\n    delimiter: {\n      pattern: /^\\{\\{\\{?|\\}\\}\\}?$/i,\n      alias: "punctuation"\n    },\n    string: /(["\'])(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    number: /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee][+-]?\\d+)?/,\n    boolean: /\\b(?:true|false)\\b/,\n    block: {\n      pattern: /^(\\s*(?:~\\s*)?)[#\\/]\\S+?(?=\\s*(?:~\\s*)?$|\\s)/i,\n      lookbehind: !0,\n      alias: "keyword"\n    },\n    brackets: {\n      pattern: /\\[[^\\]]+\\]/,\n      inside: {\n        punctuation: /\\[|\\]/,\n        variable: /[\\s\\S]+/\n      }\n    },\n    punctuation: /[!"#%&\':()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]/,\n    variable: /[^!"#%&\'()*+,\\/;<=>@\\[\\\\\\]^`{|}~\\s]+/\n  }, e.hooks.add("before-tokenize", function (a) {\n    e.languages["markup-templating"].buildPlaceholders(a, "handlebars", /\\{\\{\\{[\\s\\S]+?\\}\\}\\}|\\{\\{[\\s\\S]+?\\}\\}/g);\n  }), e.hooks.add("after-tokenize", function (a) {\n    e.languages["markup-templating"].tokenizePlaceholders(a, "handlebars");\n  }), e.languages.hbs = e.languages.handlebars;\n}(Prism);\nPrism.languages.haskell = {\n  comment: {\n    pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\\\\/].*|$)|\\{-[\\s\\S]*?-\\})/m,\n    lookbehind: !0\n  },\n  char: {\n    pattern: /\'(?:[^\\\\\']|\\\\(?:[abfnrtv\\\\"\'&]|\\^[A-Z@[\\]^_]|NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|\\d+|o[0-7]+|x[0-9a-fA-F]+))\'/,\n    alias: "string"\n  },\n  string: {\n    pattern: /"(?:[^\\\\"]|\\\\(?:\\S|\\s+\\\\))*"/,\n    greedy: !0\n  },\n  keyword: /\\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\\b/,\n  "import-statement": {\n    pattern: /(^[\\t ]*)import\\s+(?:qualified\\s+)?(?:[A-Z][\\w\']*)(?:\\.[A-Z][\\w\']*)*(?:\\s+as\\s+(?:[A-Z][\\w\']*)(?:\\.[A-Z][\\w\']*)*)?(?:\\s+hiding\\b)?/m,\n    lookbehind: !0,\n    inside: {\n      keyword: /\\b(?:import|qualified|as|hiding)\\b/,\n      punctuation: /\\./\n    }\n  },\n  builtin: /\\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\\b/,\n  number: /\\b(?:\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?|0o[0-7]+|0x[0-9a-f]+)\\b/i,\n  operator: [{\n    pattern: /`(?:[A-Z][\\w\']*\\.)*[_a-z][\\w\']*`/,\n    greedy: !0\n  }, {\n    pattern: /(\\s)\\.(?=\\s)/,\n    lookbehind: !0\n  }, /[-!#$%*+=?&@|~:<>^\\\\\\/][-!#$%*+=?&@|~.:<>^\\\\\\/]*|\\.[-!#$%*+=?&@|~.:<>^\\\\\\/]+/],\n  hvariable: {\n    pattern: /\\b(?:[A-Z][\\w\']*\\.)*[_a-z][\\w\']*/,\n    inside: {\n      punctuation: /\\./\n    }\n  },\n  constant: {\n    pattern: /\\b(?:[A-Z][\\w\']*\\.)*[A-Z][\\w\']*/,\n    inside: {\n      punctuation: /\\./\n    }\n  },\n  punctuation: /[{}[\\];(),.:]/\n}, Prism.languages.hs = Prism.languages.haskell;\n!function (t) {\n  t.languages.http = {\n    "request-line": {\n      pattern: /^(?:GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|PRI|SEARCH)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[0-9.]+/m,\n      inside: {\n        method: {\n          pattern: /^[A-Z]+\\b/,\n          alias: "property"\n        },\n        "request-target": {\n          pattern: /^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,\n          lookbehind: !0,\n          alias: "url",\n          inside: t.languages.uri\n        },\n        "http-version": {\n          pattern: /^(\\s)HTTP\\/[0-9.]+/,\n          lookbehind: !0,\n          alias: "property"\n        }\n      }\n    },\n    "response-status": {\n      pattern: /^HTTP\\/[0-9.]+ \\d+ .+/m,\n      inside: {\n        "http-version": {\n          pattern: /^HTTP\\/[0-9.]+/,\n          alias: "property"\n        },\n        "status-code": {\n          pattern: /^(\\s)\\d+(?=\\s)/,\n          lookbehind: !0,\n          alias: "number"\n        },\n        "reason-phrase": {\n          pattern: /^(\\s).+/,\n          lookbehind: !0,\n          alias: "string"\n        }\n      }\n    },\n    "header-name": {\n      pattern: /^[\\w-]+:(?=.)/m,\n      alias: "keyword"\n    }\n  };\n  var a,\n      e,\n      s,\n      n = t.languages,\n      r = {\n    "application/javascript": n.javascript,\n    "application/json": n.json || n.javascript,\n    "application/xml": n.xml,\n    "text/xml": n.xml,\n    "text/html": n.html,\n    "text/css": n.css\n  },\n      i = {\n    "application/json": !0,\n    "application/xml": !0\n  };\n\n  for (var p in r) {\n    if (r[p]) {\n      a = a || {};\n      var o = i[p] ? (void 0, s = (e = p).replace(/^[a-z]+\\//, ""), "(?:" + e + "|\\\\w+/(?:[\\\\w.-]+\\\\+)+" + s + "(?![+\\\\w.-]))") : p;\n      a[p.replace(/\\//g, "-")] = {\n        pattern: RegExp("(content-type:\\\\s*" + o + "(?:(?:\\\\r\\\\n?|\\\\n).+)*)(?:\\\\r?\\\\n|\\\\r){2}[\\\\s\\\\S]*", "i"),\n        lookbehind: !0,\n        inside: r[p]\n      };\n    }\n  }\n\n  a && t.languages.insertBefore("http", "header-name", a);\n}(Prism);\n!function (e) {\n  var t = /\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\\b/,\n      n = "(^|[^\\\\w.])(?:[a-z]\\\\w*\\\\s*\\\\.\\\\s*)*(?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*",\n      a = {\n    pattern: RegExp(n + "[A-Z](?:[\\\\d_A-Z]*[a-z]\\\\w*)?\\\\b"),\n    lookbehind: !0,\n    inside: {\n      namespace: {\n        pattern: /^[a-z]\\w*(?:\\s*\\.\\s*[a-z]\\w*)*(?:\\s*\\.)?/,\n        inside: {\n          punctuation: /\\./\n        }\n      },\n      punctuation: /\\./\n    }\n  };\n  e.languages.java = e.languages.extend("clike", {\n    "class-name": [a, {\n      pattern: RegExp(n + "[A-Z]\\\\w*(?=\\\\s+\\\\w+\\\\s*[;,=()])"),\n      lookbehind: !0,\n      inside: a.inside\n    }],\n    keyword: t,\n    function: [e.languages.clike.function, {\n      pattern: /(::\\s*)[a-z_]\\w*/,\n      lookbehind: !0\n    }],\n    number: /\\b0b[01][01_]*L?\\b|\\b0x(?:\\.[\\da-f_p+-]+|[\\da-f_]+(?:\\.[\\da-f_p+-]+)?)\\b|(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[dfl]?/i,\n    operator: {\n      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\\+\\+|&&|\\|\\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,\n      lookbehind: !0\n    }\n  }), e.languages.insertBefore("java", "string", {\n    "triple-quoted-string": {\n      pattern: /"""[ \\t]*[\\r\\n](?:(?:"|"")?(?:\\\\.|[^"\\\\]))*"""/,\n      greedy: !0,\n      alias: "string"\n    }\n  }), e.languages.insertBefore("java", "class-name", {\n    annotation: {\n      pattern: /(^|[^.])@\\w+(?:\\s*\\.\\s*\\w+)*/,\n      lookbehind: !0,\n      alias: "punctuation"\n    },\n    generics: {\n      pattern: /<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&))*>)*>)*>)*>/,\n      inside: {\n        "class-name": a,\n        keyword: t,\n        punctuation: /[<>(),.:]/,\n        operator: /[?&|]/\n      }\n    },\n    namespace: {\n      pattern: RegExp("(\\\\b(?:exports|import(?:\\\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\\\s+)(?!<keyword>)[a-z]\\\\w*(?:\\\\.[a-z]\\\\w*)*\\\\.?".replace(/<keyword>/g, function () {\n        return t.source;\n      })),\n      lookbehind: !0,\n      inside: {\n        punctuation: /\\./\n      }\n    }\n  });\n}(Prism);\nPrism.languages.json = {\n  property: {\n    pattern: /(^|[^\\\\])"(?:\\\\.|[^\\\\"\\r\\n])*"(?=\\s*:)/,\n    lookbehind: !0,\n    greedy: !0\n  },\n  string: {\n    pattern: /(^|[^\\\\])"(?:\\\\.|[^\\\\"\\r\\n])*"(?!\\s*:)/,\n    lookbehind: !0,\n    greedy: !0\n  },\n  comment: {\n    pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: !0\n  },\n  number: /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  punctuation: /[{}[\\],]/,\n  operator: /:/,\n  boolean: /\\b(?:true|false)\\b/,\n  null: {\n    pattern: /\\bnull\\b/,\n    alias: "keyword"\n  }\n}, Prism.languages.webmanifest = Prism.languages.json;\n!function (e) {\n  e.languages.kotlin = e.languages.extend("clike", {\n    keyword: {\n      pattern: /(^|[^.])\\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\\b/,\n      lookbehind: !0\n    },\n    function: [{\n      pattern: /(?:`[^\\r\\n`]+`|\\b\\w+)(?=\\s*\\()/,\n      greedy: !0\n    }, {\n      pattern: /(\\.)(?:`[^\\r\\n`]+`|\\w+)(?=\\s*\\{)/,\n      lookbehind: !0,\n      greedy: !0\n    }],\n    number: /\\b(?:0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\\d+(?:_\\d+)*(?:\\.\\d+(?:_\\d+)*)?(?:[eE][+-]?\\d+(?:_\\d+)*)?[fFL]?)\\b/,\n    operator: /\\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\\/*%<>]=?|[?:]:?|\\.\\.|&&|\\|\\||\\b(?:and|inv|or|shl|shr|ushr|xor)\\b/\n  }), delete e.languages.kotlin["class-name"], e.languages.insertBefore("kotlin", "string", {\n    "raw-string": {\n      pattern: /("""|\'\'\')[\\s\\S]*?\\1/,\n      alias: "string"\n    }\n  }), e.languages.insertBefore("kotlin", "keyword", {\n    annotation: {\n      pattern: /\\B@(?:\\w+:)?(?:[A-Z]\\w*|\\[[^\\]]+\\])/,\n      alias: "builtin"\n    }\n  }), e.languages.insertBefore("kotlin", "function", {\n    label: {\n      pattern: /\\b\\w+@|@\\w+\\b/,\n      alias: "symbol"\n    }\n  });\n  var n = [{\n    pattern: /\\$\\{[^}]+\\}/,\n    inside: {\n      delimiter: {\n        pattern: /^\\$\\{|\\}$/,\n        alias: "variable"\n      },\n      rest: e.languages.kotlin\n    }\n  }, {\n    pattern: /\\$\\w+/,\n    alias: "variable"\n  }];\n  e.languages.kotlin.string.inside = e.languages.kotlin["raw-string"].inside = {\n    interpolation: n\n  }, e.languages.kt = e.languages.kotlin, e.languages.kts = e.languages.kotlin;\n}(Prism);\n!function (a) {\n  var e = /\\\\(?:[^a-z()[\\]]|[a-z*]+)/i,\n      n = {\n    "equation-command": {\n      pattern: e,\n      alias: "regex"\n    }\n  };\n  a.languages.latex = {\n    comment: /%.*/m,\n    cdata: {\n      pattern: /(\\\\begin\\{((?:verbatim|lstlisting)\\*?)\\})[\\s\\S]*?(?=\\\\end\\{\\2\\})/,\n      lookbehind: !0\n    },\n    equation: [{\n      pattern: /\\$\\$(?:\\\\[\\s\\S]|[^\\\\$])+\\$\\$|\\$(?:\\\\[\\s\\S]|[^\\\\$])+\\$|\\\\\\([\\s\\S]*?\\\\\\)|\\\\\\[[\\s\\S]*?\\\\\\]/,\n      inside: n,\n      alias: "string"\n    }, {\n      pattern: /(\\\\begin\\{((?:equation|math|eqnarray|align|multline|gather)\\*?)\\})[\\s\\S]*?(?=\\\\end\\{\\2\\})/,\n      lookbehind: !0,\n      inside: n,\n      alias: "string"\n    }],\n    keyword: {\n      pattern: /(\\\\(?:begin|end|ref|cite|label|usepackage|documentclass)(?:\\[[^\\]]+\\])?\\{)[^}]+(?=\\})/,\n      lookbehind: !0\n    },\n    url: {\n      pattern: /(\\\\url\\{)[^}]+(?=\\})/,\n      lookbehind: !0\n    },\n    headline: {\n      pattern: /(\\\\(?:part|chapter|section|subsection|frametitle|subsubsection|paragraph|subparagraph|subsubparagraph|subsubsubparagraph)\\*?(?:\\[[^\\]]+\\])?\\{)[^}]+(?=\\})/,\n      lookbehind: !0,\n      alias: "class-name"\n    },\n    function: {\n      pattern: e,\n      alias: "selector"\n    },\n    punctuation: /[[\\]{}&]/\n  }, a.languages.tex = a.languages.latex, a.languages.context = a.languages.latex;\n}(Prism);\nPrism.languages.less = Prism.languages.extend("css", {\n  comment: [/\\/\\*[\\s\\S]*?\\*\\//, {\n    pattern: /(^|[^\\\\])\\/\\/.*/,\n    lookbehind: !0\n  }],\n  atrule: {\n    pattern: /@[\\w-](?:\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n    inside: {\n      punctuation: /[:()]/\n    }\n  },\n  selector: {\n    pattern: /(?:@\\{[\\w-]+\\}|[^{};\\s@])(?:@\\{[\\w-]+\\}|\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};@\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n    inside: {\n      variable: /@+[\\w-]+/\n    }\n  },\n  property: /(?:@\\{[\\w-]+\\}|[\\w-])+(?:\\+_?)?(?=\\s*:)/i,\n  operator: /[+\\-*\\/]/\n}), Prism.languages.insertBefore("less", "property", {\n  variable: [{\n    pattern: /@[\\w-]+\\s*:/,\n    inside: {\n      punctuation: /:/\n    }\n  }, /@@?[\\w-]+/],\n  "mixin-usage": {\n    pattern: /([{;]\\s*)[.#](?!\\d)[\\w-].*?(?=[(;])/,\n    lookbehind: !0,\n    alias: "function"\n  }\n});\nPrism.languages.llvm = {\n  comment: /;.*/,\n  string: {\n    pattern: /"[^"]*"/,\n    greedy: !0\n  },\n  boolean: /\\b(?:true|false)\\b/,\n  variable: /[%@!#](?:(?!\\d)(?:[-$.\\w]|\\\\[a-f\\d]{2})+|\\d+)/i,\n  label: /(?!\\d)(?:[-$.\\w]|\\\\[a-f\\d]{2})+:/i,\n  type: {\n    pattern: /\\b(?:double|float|fp128|half|i[1-9]\\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\\b/,\n    alias: "class-name"\n  },\n  keyword: /\\b[a-z_][a-z_0-9]*\\b/,\n  number: /[+-]?\\b\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\b|\\b0x[\\dA-Fa-f]+\\b|\\b0xK[\\dA-Fa-f]{20}\\b|\\b0x[ML][\\dA-Fa-f]{32}\\b|\\b0xH[\\dA-Fa-f]{4}\\b/,\n  punctuation: /[{}[\\];(),.!*=<>]/\n};\nPrism.languages.makefile = {\n  comment: {\n    pattern: /(^|[^\\\\])#(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n])*/,\n    lookbehind: !0\n  },\n  string: {\n    pattern: /(["\'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: !0\n  },\n  builtin: /\\.[A-Z][^:#=\\s]+(?=\\s*:(?!=))/,\n  symbol: {\n    pattern: /^(?:[^:=\\s]|[ \\t]+(?![\\s:]))+(?=\\s*:(?!=))/m,\n    inside: {\n      variable: /\\$+(?:(?!\\$)[^(){}:#=\\s]+|(?=[({]))/\n    }\n  },\n  variable: /\\$+(?:(?!\\$)[^(){}:#=\\s]+|\\([@*%<^+?][DF]\\)|(?=[({]))/,\n  keyword: [/-include\\b|\\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\\b/, {\n    pattern: /(\\()(?:addsuffix|abspath|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:s|list)?)(?=[ \\t])/,\n    lookbehind: !0\n  }],\n  operator: /(?:::|[?:+!])?=|[|@]/,\n  punctuation: /[:;(){}]/\n};\n!function (s) {\n  function n(n) {\n    return n = n.replace(/<inner>/g, function () {\n      return "(?:\\\\\\\\.|[^\\\\\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))";\n    }), RegExp("((?:^|[^\\\\\\\\])(?:\\\\\\\\{2})*)(?:" + n + ")");\n  }\n\n  var e = "(?:\\\\\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\\\\\|\\r\\n`])+",\n      t = "\\\\|?__(?:\\\\|__)+\\\\|?(?:(?:\\n|\\r\\n?)|(?![^]))".replace(/__/g, function () {\n    return e;\n  }),\n      a = "\\\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\\\|?(?:\\n|\\r\\n?)";\n  s.languages.markdown = s.languages.extend("markup", {}), s.languages.insertBefore("markdown", "prolog", {\n    "front-matter-block": {\n      pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        punctuation: /^---|---$/,\n        "font-matter": {\n          pattern: /\\S+(?:\\s+\\S+)*/,\n          alias: ["yaml", "language-yaml"],\n          inside: s.languages.yaml\n        }\n      }\n    },\n    blockquote: {\n      pattern: /^>(?:[\\t ]*>)*/m,\n      alias: "punctuation"\n    },\n    table: {\n      pattern: RegExp("^" + t + a + "(?:" + t + ")*", "m"),\n      inside: {\n        "table-data-rows": {\n          pattern: RegExp("^(" + t + a + ")(?:" + t + ")*$"),\n          lookbehind: !0,\n          inside: {\n            "table-data": {\n              pattern: RegExp(e),\n              inside: s.languages.markdown\n            },\n            punctuation: /\\|/\n          }\n        },\n        "table-line": {\n          pattern: RegExp("^(" + t + ")" + a + "$"),\n          lookbehind: !0,\n          inside: {\n            punctuation: /\\||:?-{3,}:?/\n          }\n        },\n        "table-header-row": {\n          pattern: RegExp("^" + t + "$"),\n          inside: {\n            "table-header": {\n              pattern: RegExp(e),\n              alias: "important",\n              inside: s.languages.markdown\n            },\n            punctuation: /\\|/\n          }\n        }\n      }\n    },\n    code: [{\n      pattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n      lookbehind: !0,\n      alias: "keyword"\n    }, {\n      pattern: /^```[\\s\\S]*?^```$/m,\n      greedy: !0,\n      inside: {\n        "code-block": {\n          pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n          lookbehind: !0\n        },\n        "code-language": {\n          pattern: /^(```).+/,\n          lookbehind: !0\n        },\n        punctuation: /```/\n      }\n    }],\n    title: [{\n      pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n      alias: "important",\n      inside: {\n        punctuation: /==+$|--+$/\n      }\n    }, {\n      pattern: /(^\\s*)#.+/m,\n      lookbehind: !0,\n      alias: "important",\n      inside: {\n        punctuation: /^#+|#+$/\n      }\n    }],\n    hr: {\n      pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n      lookbehind: !0,\n      alias: "punctuation"\n    },\n    list: {\n      pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n      lookbehind: !0,\n      alias: "punctuation"\n    },\n    "url-reference": {\n      pattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:"(?:\\\\.|[^"\\\\])*"|\'(?:\\\\.|[^\'\\\\])*\'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n      inside: {\n        variable: {\n          pattern: /^(!?\\[)[^\\]]+/,\n          lookbehind: !0\n        },\n        string: /(?:"(?:\\\\.|[^"\\\\])*"|\'(?:\\\\.|[^\'\\\\])*\'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n        punctuation: /^[\\[\\]!:]|[<>]/\n      },\n      alias: "url"\n    },\n    bold: {\n      pattern: n("\\\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\\\b|\\\\*\\\\*(?:(?!\\\\*)<inner>|\\\\*(?:(?!\\\\*)<inner>)+\\\\*)+\\\\*\\\\*"),\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        content: {\n          pattern: /(^..)[\\s\\S]+(?=..$)/,\n          lookbehind: !0,\n          inside: {}\n        },\n        punctuation: /\\*\\*|__/\n      }\n    },\n    italic: {\n      pattern: n("\\\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\\\b|\\\\*(?:(?!\\\\*)<inner>|\\\\*\\\\*(?:(?!\\\\*)<inner>)+\\\\*\\\\*)+\\\\*"),\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        content: {\n          pattern: /(^.)[\\s\\S]+(?=.$)/,\n          lookbehind: !0,\n          inside: {}\n        },\n        punctuation: /[*_]/\n      }\n    },\n    strike: {\n      pattern: n("(~~?)(?:(?!~)<inner>)+\\\\2"),\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        content: {\n          pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n          lookbehind: !0,\n          inside: {}\n        },\n        punctuation: /~~?/\n      }\n    },\n    "code-snippet": {\n      pattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n      lookbehind: !0,\n      greedy: !0,\n      alias: ["code", "keyword"]\n    },\n    url: {\n      pattern: n(\'!?\\\\[(?:(?!\\\\])<inner>)+\\\\](?:\\\\([^\\\\s)]+(?:[\\t ]+"(?:\\\\\\\\.|[^"\\\\\\\\])*")?\\\\)|[ \\t]?\\\\[(?:(?!\\\\])<inner>)+\\\\])\'),\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        operator: /^!/,\n        content: {\n          pattern: /(^\\[)[^\\]]+(?=\\])/,\n          lookbehind: !0,\n          inside: {}\n        },\n        variable: {\n          pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n          lookbehind: !0\n        },\n        url: {\n          pattern: /(^\\]\\()[^\\s)]+/,\n          lookbehind: !0\n        },\n        string: {\n          pattern: /(^[ \\t]+)"(?:\\\\.|[^"\\\\])*"(?=\\)$)/,\n          lookbehind: !0\n        }\n      }\n    }\n  }), ["url", "bold", "italic", "strike"].forEach(function (e) {\n    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function (n) {\n      e !== n && (s.languages.markdown[e].inside.content.inside[n] = s.languages.markdown[n]);\n    });\n  }), s.hooks.add("after-tokenize", function (n) {\n    "markdown" !== n.language && "md" !== n.language || !function n(e) {\n      if (e && "string" != typeof e) for (var t = 0, a = e.length; t < a; t++) {\n        var r = e[t];\n\n        if ("code" === r.type) {\n          var i = r.content[1],\n              o = r.content[3];\n\n          if (i && o && "code-language" === i.type && "code-block" === o.type && "string" == typeof i.content) {\n            var l = i.content.replace(/\\b#/g, "sharp").replace(/\\b\\+\\+/g, "pp"),\n                s = "language-" + (l = (/[a-z][\\w-]*/i.exec(l) || [""])[0].toLowerCase());\n            o.alias ? "string" == typeof o.alias ? o.alias = [o.alias, s] : o.alias.push(s) : o.alias = [s];\n          }\n        } else n(r.content);\n      }\n    }(n.tokens);\n  }), s.hooks.add("wrap", function (n) {\n    if ("code-block" === n.type) {\n      for (var e = "", t = 0, a = n.classes.length; t < a; t++) {\n        var r = n.classes[t],\n            i = /language-(.+)/.exec(r);\n\n        if (i) {\n          e = i[1];\n          break;\n        }\n      }\n\n      var o = s.languages[e];\n      if (o) n.content = s.highlight(function (n) {\n        var e = n.replace(d, "");\n        return e = e.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (n, e) {\n          var t;\n          if ("#" === (e = e.toLowerCase())[0]) return t = "x" === e[1] ? parseInt(e.slice(2), 16) : Number(e.slice(1)), u(t);\n          var a = p[e];\n          return a || n;\n        });\n      }(n.content), o, e);else if (e && "none" !== e && s.plugins.autoloader) {\n        var l = "md-" + new Date().valueOf() + "-" + Math.floor(1e16 * Math.random());\n        n.attributes.id = l, s.plugins.autoloader.loadLanguages(e, function () {\n          var n = document.getElementById(l);\n          n && (n.innerHTML = s.highlight(n.textContent, s.languages[e], e));\n        });\n      }\n    }\n  });\n  var d = RegExp(s.languages.markup.tag.pattern.source, "gi"),\n      p = {\n    amp: "&",\n    lt: "<",\n    gt: ">",\n    quot: \'"\'\n  },\n      u = String.fromCodePoint || String.fromCharCode;\n  s.languages.md = s.languages.markdown;\n}(Prism);\nPrism.languages.nasm = {\n  comment: /;.*$/m,\n  string: /(["\'`])(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n  label: {\n    pattern: /(^\\s*)[A-Za-z._?$][\\w.?$@~#]*:/m,\n    lookbehind: !0,\n    alias: "function"\n  },\n  keyword: [/\\[?BITS (?:16|32|64)\\]?/, {\n    pattern: /(^\\s*)section\\s*[a-z.]+:?/im,\n    lookbehind: !0\n  }, /(?:extern|global)[^;\\r\\n]*/i, /(?:CPU|FLOAT|DEFAULT).*$/m],\n  register: {\n    pattern: /\\b(?:st\\d|[xyz]mm\\d\\d?|[cdt]r\\d|r\\d\\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|sp|si|di)|[cdefgs]s)\\b/i,\n    alias: "variable"\n  },\n  number: /(?:\\b|(?=\\$))(?:0[hx](?:\\.[\\da-f]+|[\\da-f]+(?:\\.[\\da-f]+)?)(?:p[+-]?\\d+)?|\\d[\\da-f]+[hx]|\\$\\d[\\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\\d+|(?:\\d+(?:\\.\\d+)?|\\.\\d+)(?:\\.?e[+-]?\\d+)?[dt]?)\\b/i,\n  operator: /[\\[\\]*+\\-\\/%<>=&|$!]/\n};\nPrism.languages.objectivec = Prism.languages.extend("c", {\n  string: /("|\')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1|@"(?:\\\\(?:\\r\\n|[\\s\\S])|[^"\\\\\\r\\n])*"/,\n  keyword: /\\b(?:asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while|in|self|super)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n  operator: /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n}), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec;\nPrism.languages.ocaml = {\n  comment: /\\(\\*[\\s\\S]*?\\*\\)/,\n  string: [{\n    pattern: /"(?:\\\\.|[^\\\\\\r\\n"])*"/,\n    greedy: !0\n  }, {\n    pattern: /([\'`])(?:\\\\(?:\\d+|x[\\da-f]+|.)|(?!\\1)[^\\\\\\r\\n])\\1/i,\n    greedy: !0\n  }],\n  number: /\\b(?:0x[\\da-f][\\da-f_]+|(?:0[bo])?\\d[\\d_]*(?:\\.[\\d_]*)?(?:e[+-]?[\\d_]+)?)/i,\n  directive: {\n    pattern: /\\B#\\w+/,\n    alias: "important"\n  },\n  label: {\n    pattern: /\\B~\\w+/,\n    alias: "function"\n  },\n  "type-variable": {\n    pattern: /\\B\'\\w+/,\n    alias: "function"\n  },\n  variant: {\n    pattern: /`\\w+/,\n    alias: "variable"\n  },\n  module: {\n    pattern: /\\b[A-Z]\\w+/,\n    alias: "variable"\n  },\n  keyword: /\\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\\b/,\n  boolean: /\\b(?:false|true)\\b/,\n  operator: /:=|[=<>@^|&+\\-*\\/$%!?~][!$%&*+\\-.\\/:<=>?@^|~]*|\\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\\b/,\n  punctuation: /[(){}\\[\\]|.,:;]|\\b_\\b/\n};\nPrism.languages.perl = {\n  comment: [{\n    pattern: /(^\\s*)=\\w[\\s\\S]*?=cut.*/m,\n    lookbehind: !0\n  }, {\n    pattern: /(^|[^\\\\$])#.*/,\n    lookbehind: !0\n  }],\n  string: [{\n    pattern: /\\b(?:q|qq|qx|qw)\\s*([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:q|qq|qx|qw)\\s+([a-zA-Z0-9])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:q|qq|qx|qw)\\s*\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:q|qq|qx|qw)\\s*\\{(?:[^{}\\\\]|\\\\[\\s\\S])*\\}/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:q|qq|qx|qw)\\s*\\[(?:[^[\\]\\\\]|\\\\[\\s\\S])*\\]/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:q|qq|qx|qw)\\s*<(?:[^<>\\\\]|\\\\[\\s\\S])*>/,\n    greedy: !0\n  }, {\n    pattern: /("|`)(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,\n    greedy: !0\n  }, {\n    pattern: /\'(?:[^\'\\\\\\r\\n]|\\\\.)*\'/,\n    greedy: !0\n  }],\n  regex: [{\n    pattern: /\\b(?:m|qr)\\s*([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1[msixpodualngc]*/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:m|qr)\\s+([a-zA-Z0-9])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1[msixpodualngc]*/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:m|qr)\\s*\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)[msixpodualngc]*/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:m|qr)\\s*\\{(?:[^{}\\\\]|\\\\[\\s\\S])*\\}[msixpodualngc]*/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:m|qr)\\s*\\[(?:[^[\\]\\\\]|\\\\[\\s\\S])*\\][msixpodualngc]*/,\n    greedy: !0\n  }, {\n    pattern: /\\b(?:m|qr)\\s*<(?:[^<>\\\\]|\\\\[\\s\\S])*>[msixpodualngc]*/,\n    greedy: !0\n  }, {\n    pattern: /(^|[^-]\\b)(?:s|tr|y)\\s*([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2[msixpodualngcer]*/,\n    lookbehind: !0,\n    greedy: !0\n  }, {\n    pattern: /(^|[^-]\\b)(?:s|tr|y)\\s+([a-zA-Z0-9])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2[msixpodualngcer]*/,\n    lookbehind: !0,\n    greedy: !0\n  }, {\n    pattern: /(^|[^-]\\b)(?:s|tr|y)\\s*\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)\\s*\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)[msixpodualngcer]*/,\n    lookbehind: !0,\n    greedy: !0\n  }, {\n    pattern: /(^|[^-]\\b)(?:s|tr|y)\\s*\\{(?:[^{}\\\\]|\\\\[\\s\\S])*\\}\\s*\\{(?:[^{}\\\\]|\\\\[\\s\\S])*\\}[msixpodualngcer]*/,\n    lookbehind: !0,\n    greedy: !0\n  }, {\n    pattern: /(^|[^-]\\b)(?:s|tr|y)\\s*\\[(?:[^[\\]\\\\]|\\\\[\\s\\S])*\\]\\s*\\[(?:[^[\\]\\\\]|\\\\[\\s\\S])*\\][msixpodualngcer]*/,\n    lookbehind: !0,\n    greedy: !0\n  }, {\n    pattern: /(^|[^-]\\b)(?:s|tr|y)\\s*<(?:[^<>\\\\]|\\\\[\\s\\S])*>\\s*<(?:[^<>\\\\]|\\\\[\\s\\S])*>[msixpodualngcer]*/,\n    lookbehind: !0,\n    greedy: !0\n  }, {\n    pattern: /\\/(?:[^\\/\\\\\\r\\n]|\\\\.)*\\/[msixpodualngc]*(?=\\s*(?:$|[\\r\\n,.;})&|\\-+*~<>!?^]|(?:lt|gt|le|ge|eq|ne|cmp|not|and|or|xor|x)\\b))/,\n    greedy: !0\n  }],\n  variable: [/[&*$@%]\\{\\^[A-Z]+\\}/, /[&*$@%]\\^[A-Z_]/, /[&*$@%]#?(?=\\{)/, /[&*$@%]#?(?:(?:::)*\'?(?!\\d)[\\w$]+(?![\\w$]))+(?:::)*/i, /[&*$@%]\\d+/, /(?!%=)[$@%][!"#$%&\'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~]/],\n  filehandle: {\n    pattern: /<(?![<=])\\S*>|\\b_\\b/,\n    alias: "symbol"\n  },\n  vstring: {\n    pattern: /v\\d+(?:\\.\\d+)*|\\d+(?:\\.\\d+){2,}/,\n    alias: "string"\n  },\n  function: {\n    pattern: /sub \\w+/i,\n    inside: {\n      keyword: /sub/\n    }\n  },\n  keyword: /\\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\\b/,\n  number: /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)\\b/,\n  operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\\b|\\+[+=]?|-[-=>]?|\\*\\*?=?|\\/\\/?=?|=[=~>]?|~[~=]?|\\|\\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\\.(?:=|\\.\\.?)?|[\\\\?]|\\bx(?:=|\\b)|\\b(?:lt|gt|le|ge|eq|ne|cmp|not|and|or|xor)\\b/,\n  punctuation: /[{}[\\];(),:]/\n};\n!function (a) {\n  var e = /\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*|#(?!\\[).*/,\n      t = [{\n    pattern: /\\b(?:false|true)\\b/i,\n    alias: "boolean"\n  }, {\n    pattern: /(::\\s*)\\b[a-z_]\\w*\\b(?!\\s*\\()/i,\n    greedy: !0,\n    lookbehind: !0\n  }, {\n    pattern: /(\\b(?:case|const)\\s+)\\b[a-z_]\\w*(?=\\s*[;=])/i,\n    greedy: !0,\n    lookbehind: !0\n  }, /\\b(?:null)\\b/i, /\\b[A-Z_][A-Z0-9_]*\\b(?!\\s*\\()/],\n      i = /\\b0b[01]+(?:_[01]+)*\\b|\\b0o[0-7]+(?:_[0-7]+)*\\b|\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b|(?:\\b\\d+(?:_\\d+)*\\.?(?:\\d+(?:_\\d+)*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n      n = /<?=>|\\?\\?=?|\\.{3}|\\??->|[!=]=?=?|::|\\*\\*=?|--|\\+\\+|&&|\\|\\||<<|>>|[?~]|[/^|%*&<>.+-]=?/,\n      s = /[{}\\[\\](),:;]/;\n  a.languages.php = {\n    delimiter: {\n      pattern: /\\?>$|^<\\?(?:php(?=\\s)|=)?/i,\n      alias: "important"\n    },\n    comment: e,\n    variable: /\\$+(?:\\w+\\b|(?=\\{))/i,\n    package: {\n      pattern: /(namespace\\s+|use\\s+(?:function\\s+)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n      lookbehind: !0,\n      inside: {\n        punctuation: /\\\\/\n      }\n    },\n    "class-name-definition": {\n      pattern: /(\\b(?:class|enum|interface|trait)\\s+)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n      lookbehind: !0,\n      alias: "class-name"\n    },\n    "function-definition": {\n      pattern: /(\\bfunction\\s+)[a-z_]\\w*(?=\\s*\\()/i,\n      lookbehind: !0,\n      alias: "function"\n    },\n    keyword: [{\n      pattern: /(\\(\\s*)\\b(?:bool|boolean|int|integer|float|string|object|array)\\b(?=\\s*\\))/i,\n      alias: "type-casting",\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /([(,?]\\s*)\\b(?:bool|int|float|string|object|array(?!\\s*\\()|mixed|self|static|callable|iterable|(?:null|false)(?=\\s*\\|))\\b(?=\\s*\\$)/i,\n      alias: "type-hint",\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /([(,?]\\s*[\\w|]\\|\\s*)(?:null|false)\\b(?=\\s*\\$)/i,\n      alias: "type-hint",\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b(?:bool|int|float|string|object|void|array(?!\\s*\\()|mixed|self|static|callable|iterable|(?:null|false)(?=\\s*\\|))\\b/i,\n      alias: "return-type",\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?[\\w|]\\|\\s*)(?:null|false)\\b/i,\n      alias: "return-type",\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /\\b(?:bool|int|float|string|object|void|array(?!\\s*\\()|mixed|iterable|(?:null|false)(?=\\s*\\|))\\b/i,\n      alias: "type-declaration",\n      greedy: !0\n    }, {\n      pattern: /(\\|\\s*)(?:null|false)\\b/i,\n      alias: "type-declaration",\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /\\b(?:parent|self|static)(?=\\s*::)/i,\n      alias: "static-context",\n      greedy: !0\n    }, {\n      pattern: /(\\byield\\s+)from\\b/i,\n      lookbehind: !0\n    }, /\\bclass\\b/i, {\n      pattern: /((?:^|[^\\s>:]|(?:^|[^-])>|(?:^|[^:]):)\\s*)\\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|match|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\\b/i,\n      lookbehind: !0\n    }],\n    "argument-name": {\n      pattern: /([(,]\\s+)\\b[a-z_]\\w*(?=\\s*:(?!:))/i,\n      lookbehind: !0\n    },\n    "class-name": [{\n      pattern: /(\\b(?:extends|implements|instanceof|new(?!\\s+self|\\s+static))\\s+|\\bcatch\\s*\\()\\b[a-z_]\\w*(?!\\\\)\\b/i,\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /(\\|\\s*)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /\\b[a-z_]\\w*(?!\\\\)\\b(?=\\s*\\|)/i,\n      greedy: !0\n    }, {\n      pattern: /(\\|\\s*)(?:\\\\?\\b[a-z_]\\w*)+\\b/i,\n      alias: "class-name-fully-qualified",\n      greedy: !0,\n      lookbehind: !0,\n      inside: {\n        punctuation: /\\\\/\n      }\n    }, {\n      pattern: /(?:\\\\?\\b[a-z_]\\w*)+\\b(?=\\s*\\|)/i,\n      alias: "class-name-fully-qualified",\n      greedy: !0,\n      inside: {\n        punctuation: /\\\\/\n      }\n    }, {\n      pattern: /(\\b(?:extends|implements|instanceof|new(?!\\s+self\\b|\\s+static\\b))\\s+|\\bcatch\\s*\\()(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n      alias: "class-name-fully-qualified",\n      greedy: !0,\n      lookbehind: !0,\n      inside: {\n        punctuation: /\\\\/\n      }\n    }, {\n      pattern: /\\b[a-z_]\\w*(?=\\s*\\$)/i,\n      alias: "type-declaration",\n      greedy: !0\n    }, {\n      pattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n      alias: ["class-name-fully-qualified", "type-declaration"],\n      greedy: !0,\n      inside: {\n        punctuation: /\\\\/\n      }\n    }, {\n      pattern: /\\b[a-z_]\\w*(?=\\s*::)/i,\n      alias: "static-context",\n      greedy: !0\n    }, {\n      pattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*::)/i,\n      alias: ["class-name-fully-qualified", "static-context"],\n      greedy: !0,\n      inside: {\n        punctuation: /\\\\/\n      }\n    }, {\n      pattern: /([(,?]\\s*)[a-z_]\\w*(?=\\s*\\$)/i,\n      alias: "type-hint",\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /([(,?]\\s*)(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n      alias: ["class-name-fully-qualified", "type-hint"],\n      greedy: !0,\n      lookbehind: !0,\n      inside: {\n        punctuation: /\\\\/\n      }\n    }, {\n      pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n      alias: "return-type",\n      greedy: !0,\n      lookbehind: !0\n    }, {\n      pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n      alias: ["class-name-fully-qualified", "return-type"],\n      greedy: !0,\n      lookbehind: !0,\n      inside: {\n        punctuation: /\\\\/\n      }\n    }],\n    constant: t,\n    function: {\n      pattern: /(^|[^\\\\\\w])\\\\?[a-z_](?:[\\w\\\\]*\\w)?(?=\\s*\\()/i,\n      lookbehind: !0,\n      inside: {\n        punctuation: /\\\\/\n      }\n    },\n    property: {\n      pattern: /(->\\s*)\\w+/,\n      lookbehind: !0\n    },\n    number: i,\n    operator: n,\n    punctuation: s\n  };\n  var l = {\n    pattern: /\\{\\$(?:\\{(?:\\{[^{}]+\\}|[^{}]+)\\}|[^{}])+\\}|(^|[^\\\\{])\\$+(?:\\w+(?:\\[[^\\r\\n\\[\\]]+\\]|->\\w+)?)/,\n    lookbehind: !0,\n    inside: a.languages.php\n  },\n      r = [{\n    pattern: /<<<\'([^\']+)\'[\\r\\n](?:.*[\\r\\n])*?\\1;/,\n    alias: "nowdoc-string",\n    greedy: !0,\n    inside: {\n      delimiter: {\n        pattern: /^<<<\'[^\']+\'|[a-z_]\\w*;$/i,\n        alias: "symbol",\n        inside: {\n          punctuation: /^<<<\'?|[\';]$/\n        }\n      }\n    }\n  }, {\n    pattern: /<<<(?:"([^"]+)"[\\r\\n](?:.*[\\r\\n])*?\\1;|([a-z_]\\w*)[\\r\\n](?:.*[\\r\\n])*?\\2;)/i,\n    alias: "heredoc-string",\n    greedy: !0,\n    inside: {\n      delimiter: {\n        pattern: /^<<<(?:"[^"]+"|[a-z_]\\w*)|[a-z_]\\w*;$/i,\n        alias: "symbol",\n        inside: {\n          punctuation: /^<<<"?|[";]$/\n        }\n      },\n      interpolation: l\n    }\n  }, {\n    pattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n    alias: "backtick-quoted-string",\n    greedy: !0\n  }, {\n    pattern: /\'(?:\\\\[\\s\\S]|[^\\\\\'])*\'/,\n    alias: "single-quoted-string",\n    greedy: !0\n  }, {\n    pattern: /"(?:\\\\[\\s\\S]|[^\\\\"])*"/,\n    alias: "double-quoted-string",\n    greedy: !0,\n    inside: {\n      interpolation: l\n    }\n  }];\n  a.languages.insertBefore("php", "variable", {\n    string: r,\n    attribute: {\n      pattern: /#\\[(?:[^"\'\\/#]|\\/(?![*/])|\\/\\/.*$|#(?!\\[).*$|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|"(?:\\\\[\\s\\S]|[^\\\\"])*"|\'(?:\\\\[\\s\\S]|[^\\\\\'])*\')+\\](?=\\s*[a-z$#])/im,\n      greedy: !0,\n      inside: {\n        "attribute-content": {\n          pattern: /^(#\\[)[\\s\\S]+(?=\\]$)/,\n          lookbehind: !0,\n          inside: {\n            comment: e,\n            string: r,\n            "attribute-class-name": [{\n              pattern: /([^:]|^)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n              alias: "class-name",\n              greedy: !0,\n              lookbehind: !0\n            }, {\n              pattern: /([^:]|^)(?:\\\\?\\b[a-z_]\\w*)+/i,\n              alias: ["class-name", "class-name-fully-qualified"],\n              greedy: !0,\n              lookbehind: !0,\n              inside: {\n                punctuation: /\\\\/\n              }\n            }],\n            constant: t,\n            number: i,\n            operator: n,\n            punctuation: s\n          }\n        },\n        delimiter: {\n          pattern: /^#\\[|\\]$/,\n          alias: "punctuation"\n        }\n      }\n    }\n  }), a.hooks.add("before-tokenize", function (e) {\n    if (/<\\?/.test(e.code)) {\n      a.languages["markup-templating"].buildPlaceholders(e, "php", /<\\?(?:[^"\'/#]|\\/(?![*/])|("|\')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|(?:\\/\\/|#(?!\\[))(?:[^?\\n\\r]|\\?(?!>))*(?=$|\\?>|[\\r\\n])|#\\[|\\/\\*(?:[^*]|\\*(?!\\/))*(?:\\*\\/|$))*?(?:\\?>|$)/gi);\n    }\n  }), a.hooks.add("after-tokenize", function (e) {\n    a.languages["markup-templating"].tokenizePlaceholders(e, "php");\n  });\n}(Prism);\nPrism.languages.insertBefore("php", "variable", {\n  this: /\\$this\\b/,\n  global: /\\$(?:_(?:SERVER|GET|POST|FILES|REQUEST|SESSION|ENV|COOKIE)|GLOBALS|HTTP_RAW_POST_DATA|argc|argv|php_errormsg|http_response_header)\\b/,\n  scope: {\n    pattern: /\\b[\\w\\\\]+::/,\n    inside: {\n      keyword: /static|self|parent/,\n      punctuation: /::|\\\\/\n    }\n  }\n});\n!function (e) {\n  var i = Prism.languages.powershell = {\n    comment: [{\n      pattern: /(^|[^`])<#[\\s\\S]*?#>/,\n      lookbehind: !0\n    }, {\n      pattern: /(^|[^`])#.*/,\n      lookbehind: !0\n    }],\n    string: [{\n      pattern: /"(?:`[\\s\\S]|[^`"])*"/,\n      greedy: !0,\n      inside: {\n        function: {\n          pattern: /(^|[^`])\\$\\((?:\\$\\([^\\r\\n()]*\\)|(?!\\$\\()[^\\r\\n)])*\\)/,\n          lookbehind: !0,\n          inside: {}\n        }\n      }\n    }, {\n      pattern: /\'(?:[^\']|\'\')*\'/,\n      greedy: !0\n    }],\n    namespace: /\\[[a-z](?:\\[(?:\\[[^\\]]*\\]|[^\\[\\]])*\\]|[^\\[\\]])*\\]/i,\n    boolean: /\\$(?:true|false)\\b/i,\n    variable: /\\$\\w+\\b/,\n    function: [/\\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\\b/i, /\\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\\b/i],\n    keyword: /\\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\\b/i,\n    operator: {\n      pattern: /(\\W?)(?:!|-(?:eq|ne|gt|ge|lt|le|sh[lr]|not|b?(?:and|x?or)|(?:Not)?(?:Like|Match|Contains|In)|Replace|Join|is(?:Not)?|as)\\b|-[-=]?|\\+[+=]?|[*\\/%]=?)/i,\n      lookbehind: !0\n    },\n    punctuation: /[|{}[\\];(),.]/\n  },\n      r = i.string[0].inside;\n  r.boolean = i.boolean, r.variable = i.variable, r.function.inside = i;\n}();\nPrism.languages.processing = Prism.languages.extend("clike", {\n  keyword: /\\b(?:break|catch|case|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\\b/,\n  operator: /<[<=]?|>[>=]?|&&?|\\|\\|?|[%?]|[!=+\\-*\\/]=?/\n}), Prism.languages.insertBefore("processing", "number", {\n  constant: /\\b(?!XML\\b)[A-Z][A-Z\\d_]+\\b/,\n  type: {\n    pattern: /\\b(?:boolean|byte|char|color|double|float|int|[A-Z]\\w*)\\b/,\n    alias: "variable"\n  }\n}), Prism.languages.processing.function = /\\b\\w+(?=\\s*\\()/, Prism.languages.processing["class-name"].alias = "variable";\n!function (e) {\n  e.languages.pug = {\n    comment: {\n      pattern: /(^([\\t ]*))\\/\\/.*(?:(?:\\r?\\n|\\r)\\2[\\t ].+)*/m,\n      lookbehind: !0\n    },\n    "multiline-script": {\n      pattern: /(^([\\t ]*)script\\b.*\\.[\\t ]*)(?:(?:\\r?\\n|\\r(?!\\n))(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+/m,\n      lookbehind: !0,\n      inside: e.languages.javascript\n    },\n    filter: {\n      pattern: /(^([\\t ]*)):.+(?:(?:\\r?\\n|\\r(?!\\n))(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+/m,\n      lookbehind: !0,\n      inside: {\n        "filter-name": {\n          pattern: /^:[\\w-]+/,\n          alias: "variable"\n        }\n      }\n    },\n    "multiline-plain-text": {\n      pattern: /(^([\\t ]*)[\\w\\-#.]+\\.[\\t ]*)(?:(?:\\r?\\n|\\r(?!\\n))(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+/m,\n      lookbehind: !0\n    },\n    markup: {\n      pattern: /(^[\\t ]*)<.+/m,\n      lookbehind: !0,\n      inside: e.languages.markup\n    },\n    doctype: {\n      pattern: /((?:^|\\n)[\\t ]*)doctype(?: .+)?/,\n      lookbehind: !0\n    },\n    "flow-control": {\n      pattern: /(^[\\t ]*)(?:if|unless|else|case|when|default|each|while)\\b(?: .+)?/m,\n      lookbehind: !0,\n      inside: {\n        each: {\n          pattern: /^each .+? in\\b/,\n          inside: {\n            keyword: /\\b(?:each|in)\\b/,\n            punctuation: /,/\n          }\n        },\n        branch: {\n          pattern: /^(?:if|unless|else|case|when|default|while)\\b/,\n          alias: "keyword"\n        },\n        rest: e.languages.javascript\n      }\n    },\n    keyword: {\n      pattern: /(^[\\t ]*)(?:block|extends|include|append|prepend)\\b.+/m,\n      lookbehind: !0\n    },\n    mixin: [{\n      pattern: /(^[\\t ]*)mixin .+/m,\n      lookbehind: !0,\n      inside: {\n        keyword: /^mixin/,\n        function: /\\w+(?=\\s*\\(|\\s*$)/,\n        punctuation: /[(),.]/\n      }\n    }, {\n      pattern: /(^[\\t ]*)\\+.+/m,\n      lookbehind: !0,\n      inside: {\n        name: {\n          pattern: /^\\+\\w+/,\n          alias: "function"\n        },\n        rest: e.languages.javascript\n      }\n    }],\n    script: {\n      pattern: /(^[\\t ]*script(?:(?:&[^(]+)?\\([^)]+\\))*[\\t ]).+/m,\n      lookbehind: !0,\n      inside: e.languages.javascript\n    },\n    "plain-text": {\n      pattern: /(^[\\t ]*(?!-)[\\w\\-#.]*[\\w\\-](?:(?:&[^(]+)?\\([^)]+\\))*\\/?[\\t ]).+/m,\n      lookbehind: !0\n    },\n    tag: {\n      pattern: /(^[\\t ]*)(?!-)[\\w\\-#.]*[\\w\\-](?:(?:&[^(]+)?\\([^)]+\\))*\\/?:?/m,\n      lookbehind: !0,\n      inside: {\n        attributes: [{\n          pattern: /&[^(]+\\([^)]+\\)/,\n          inside: e.languages.javascript\n        }, {\n          pattern: /\\([^)]+\\)/,\n          inside: {\n            "attr-value": {\n              pattern: /(=\\s*(?!\\s))(?:\\{[^}]*\\}|[^,)\\r\\n]+)/,\n              lookbehind: !0,\n              inside: e.languages.javascript\n            },\n            "attr-name": /[\\w-]+(?=\\s*!?=|\\s*[,)])/,\n            punctuation: /[!=(),]+/\n          }\n        }],\n        punctuation: /:/,\n        "attr-id": /#[\\w\\-]+/,\n        "attr-class": /\\.[\\w\\-]+/\n      }\n    },\n    code: [{\n      pattern: /(^[\\t ]*(?:-|!?=)).+/m,\n      lookbehind: !0,\n      inside: e.languages.javascript\n    }],\n    punctuation: /[.\\-!=|]+/\n  };\n\n  for (var t = [{\n    filter: "atpl",\n    language: "twig"\n  }, {\n    filter: "coffee",\n    language: "coffeescript"\n  }, "ejs", "handlebars", "less", "livescript", "markdown", {\n    filter: "sass",\n    language: "scss"\n  }, "stylus"], n = {}, a = 0, i = t.length; a < i; a++) {\n    var r = t[a];\n    r = "string" == typeof r ? {\n      filter: r,\n      language: r\n    } : r, e.languages[r.language] && (n["filter-" + r.filter] = {\n      pattern: RegExp("(^([\\t ]*)):<filter_name>(?:(?:\\r?\\n|\\r(?!\\n))(?:\\\\2[\\t ].+|\\\\s*?(?=\\r?\\n|\\r)))+".replace("<filter_name>", function () {\n        return r.filter;\n      }), "m"),\n      lookbehind: !0,\n      inside: {\n        "filter-name": {\n          pattern: /^:[\\w-]+/,\n          alias: "variable"\n        },\n        rest: e.languages[r.language]\n      }\n    });\n  }\n\n  e.languages.insertBefore("pug", "filter", n);\n}(Prism);\nPrism.languages.python = {\n  comment: {\n    pattern: /(^|[^\\\\])#.*/,\n    lookbehind: !0\n  },\n  "string-interpolation": {\n    pattern: /(?:f|rf|fr)(?:("""|\'\'\')[\\s\\S]*?\\1|("|\')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n    greedy: !0,\n    inside: {\n      interpolation: {\n        pattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n        lookbehind: !0,\n        inside: {\n          "format-spec": {\n            pattern: /(:)[^:(){}]+(?=\\}$)/,\n            lookbehind: !0\n          },\n          "conversion-option": {\n            pattern: /![sra](?=[:}]$)/,\n            alias: "punctuation"\n          },\n          rest: null\n        }\n      },\n      string: /[\\s\\S]+/\n    }\n  },\n  "triple-quoted-string": {\n    pattern: /(?:[rub]|rb|br)?("""|\'\'\')[\\s\\S]*?\\1/i,\n    greedy: !0,\n    alias: "string"\n  },\n  string: {\n    pattern: /(?:[rub]|rb|br)?("|\')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n    greedy: !0\n  },\n  function: {\n    pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n    lookbehind: !0\n  },\n  "class-name": {\n    pattern: /(\\bclass\\s+)\\w+/i,\n    lookbehind: !0\n  },\n  decorator: {\n    pattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/im,\n    lookbehind: !0,\n    alias: ["annotation", "punctuation"],\n    inside: {\n      punctuation: /\\./\n    }\n  },\n  keyword: /\\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n  builtin: /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n  boolean: /\\b(?:True|False|None)\\b/,\n  number: /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?\\b/i,\n  operator: /[-+%=]=?|!=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n  punctuation: /[{}[\\];(),.:]/\n}, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python;\nPrism.languages.r = {\n  comment: /#.*/,\n  string: {\n    pattern: /([\'"])(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: !0\n  },\n  "percent-operator": {\n    pattern: /%[^%\\s]*%/,\n    alias: "operator"\n  },\n  boolean: /\\b(?:TRUE|FALSE)\\b/,\n  ellipsis: /\\.\\.(?:\\.|\\d+)/,\n  number: [/\\b(?:NaN|Inf)\\b/, /(?:\\b0x[\\dA-Fa-f]+(?:\\.\\d*)?|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[EePp][+-]?\\d+)?[iL]?/],\n  keyword: /\\b(?:if|else|repeat|while|function|for|in|next|break|NULL|NA|NA_integer_|NA_real_|NA_complex_|NA_character_)\\b/,\n  operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\\|\\|?|[+*\\/^$@~]/,\n  punctuation: /[(){}\\[\\],;]/\n};\n!function (i) {\n  var t = i.util.clone(i.languages.javascript),\n      e = "(?:\\\\{<S>*\\\\.{3}(?:[^{}]|<BRACES>)*\\\\})";\n\n  function n(t, n) {\n    return t = t.replace(/<S>/g, function () {\n      return "(?:\\\\s|//.*(?!.)|/\\\\*(?:[^*]|\\\\*(?!/))\\\\*/)";\n    }).replace(/<BRACES>/g, function () {\n      return "(?:\\\\{(?:\\\\{(?:\\\\{[^{}]*\\\\}|[^{}])*\\\\}|[^{}])*\\\\})";\n    }).replace(/<SPREAD>/g, function () {\n      return e;\n    }), RegExp(t, n);\n  }\n\n  e = n(e).source, i.languages.jsx = i.languages.extend("markup", t), i.languages.jsx.tag.pattern = n("</?(?:[\\\\w.:-]+(?:<S>+(?:[\\\\w.:$-]+(?:=(?:\\"(?:\\\\\\\\[^]|[^\\\\\\\\\\"])*\\"|\'(?:\\\\\\\\[^]|[^\\\\\\\\\'])*\'|[^\\\\s{\'\\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*/?)?>"), i.languages.jsx.tag.inside.tag.pattern = /^<\\/?[^\\s>\\/]*/i, i.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\\{)(?:"(?:\\\\[\\s\\S]|[^\\\\"])*"|\'(?:\\\\[\\s\\S]|[^\\\\\'])*\'|[^\\s\'">]+)/i, i.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/, i.languages.jsx.tag.inside.comment = t.comment, i.languages.insertBefore("inside", "attr-name", {\n    spread: {\n      pattern: n("<SPREAD>"),\n      inside: i.languages.jsx\n    }\n  }, i.languages.jsx.tag), i.languages.insertBefore("inside", "special-attr", {\n    script: {\n      pattern: n("=<BRACES>"),\n      inside: {\n        "script-punctuation": {\n          pattern: /^=(?=\\{)/,\n          alias: "punctuation"\n        },\n        rest: i.languages.jsx\n      },\n      alias: "language-javascript"\n    }\n  }, i.languages.jsx.tag);\n\n  var o = function o(t) {\n    return t ? "string" == typeof t ? t : "string" == typeof t.content ? t.content : t.content.map(o).join("") : "";\n  },\n      r = function r(t) {\n    for (var n = [], e = 0; e < t.length; e++) {\n      var a = t[e],\n          s = !1;\n\n      if ("string" != typeof a && ("tag" === a.type && a.content[0] && "tag" === a.content[0].type ? "</" === a.content[0].content[0].content ? 0 < n.length && n[n.length - 1].tagName === o(a.content[0].content[1]) && n.pop() : "/>" === a.content[a.content.length - 1].content || n.push({\n        tagName: o(a.content[0].content[1]),\n        openedBraces: 0\n      }) : 0 < n.length && "punctuation" === a.type && "{" === a.content ? n[n.length - 1].openedBraces++ : 0 < n.length && 0 < n[n.length - 1].openedBraces && "punctuation" === a.type && "}" === a.content ? n[n.length - 1].openedBraces-- : s = !0), (s || "string" == typeof a) && 0 < n.length && 0 === n[n.length - 1].openedBraces) {\n        var g = o(a);\n        e < t.length - 1 && ("string" == typeof t[e + 1] || "plain-text" === t[e + 1].type) && (g += o(t[e + 1]), t.splice(e + 1, 1)), 0 < e && ("string" == typeof t[e - 1] || "plain-text" === t[e - 1].type) && (g = o(t[e - 1]) + g, t.splice(e - 1, 1), e--), t[e] = new i.Token("plain-text", g, null, g);\n      }\n\n      a.content && "string" != typeof a.content && r(a.content);\n    }\n  };\n\n  i.hooks.add("after-tokenize", function (t) {\n    "jsx" !== t.language && "tsx" !== t.language || r(t.tokens);\n  });\n}(Prism);\n!function (e) {\n  e.languages.typescript = e.languages.extend("javascript", {\n    "class-name": {\n      pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n      lookbehind: !0,\n      greedy: !0,\n      inside: null\n    },\n    builtin: /\\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\\b/\n  }), e.languages.typescript.keyword.push(/\\b(?:abstract|as|declare|implements|is|keyof|readonly|require)\\b/, /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/, /\\btype\\b(?=\\s*(?:[\\{*]|$))/), delete e.languages.typescript.parameter;\n  var s = e.languages.extend("typescript", {});\n  delete s["class-name"], e.languages.typescript["class-name"].inside = s, e.languages.insertBefore("typescript", "function", {\n    decorator: {\n      pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n      inside: {\n        at: {\n          pattern: /^@/,\n          alias: "operator"\n        },\n        function: /^[\\s\\S]+/\n      }\n    },\n    "generic-function": {\n      pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n      greedy: !0,\n      inside: {\n        function: /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n        generic: {\n          pattern: /<[\\s\\S]+/,\n          alias: "class-name",\n          inside: s\n        }\n      }\n    }\n  }), e.languages.ts = e.languages.typescript;\n}(Prism);\n!function (a) {\n  var e = a.util.clone(a.languages.typescript);\n  a.languages.tsx = a.languages.extend("jsx", e);\n  var t = a.languages.tsx.tag;\n  t.pattern = RegExp("(^|[^\\\\w$]|(?=</))(?:" + t.pattern.source + ")", t.pattern.flags), t.lookbehind = !0;\n}(Prism);\nPrism.languages.reason = Prism.languages.extend("clike", {\n  string: {\n    pattern: /"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n"])*"/,\n    greedy: !0\n  },\n  "class-name": /\\b[A-Z]\\w*/,\n  keyword: /\\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\\b/,\n  operator: /\\.{3}|:[:=]|\\|>|->|=(?:==?|>)?|<=?|>=?|[|^?\'#!~`]|[+\\-*\\/]\\.?|\\b(?:mod|land|lor|lxor|lsl|lsr|asr)\\b/\n}), Prism.languages.insertBefore("reason", "class-name", {\n  character: {\n    pattern: /\'(?:\\\\x[\\da-f]{2}|\\\\o[0-3][0-7][0-7]|\\\\\\d{3}|\\\\.|[^\'\\\\\\r\\n])\'/,\n    alias: "string"\n  },\n  constructor: {\n    pattern: /\\b[A-Z]\\w*\\b(?!\\s*\\.)/,\n    alias: "variable"\n  },\n  label: {\n    pattern: /\\b[a-z]\\w*(?=::)/,\n    alias: "symbol"\n  }\n}), delete Prism.languages.reason.function;\n!function (e) {\n  for (var a = "/\\\\*(?:[^*/]|\\\\*(?!/)|/(?!\\\\*)|<self>)*\\\\*/", t = 0; t < 2; t++) {\n    a = a.replace(/<self>/g, function () {\n      return a;\n    });\n  }\n\n  a = a.replace(/<self>/g, function () {\n    return "[^\\\\s\\\\S]";\n  }), e.languages.rust = {\n    comment: [{\n      pattern: RegExp("(^|[^\\\\\\\\])" + a),\n      lookbehind: !0,\n      greedy: !0\n    }, {\n      pattern: /(^|[^\\\\:])\\/\\/.*/,\n      lookbehind: !0,\n      greedy: !0\n    }],\n    string: {\n      pattern: /b?"(?:\\\\[\\s\\S]|[^\\\\"])*"|b?r(#*)"(?:[^"]|"(?!\\1))*"\\1/,\n      greedy: !0\n    },\n    char: {\n      pattern: /b?\'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t\'])\'/,\n      greedy: !0,\n      alias: "string"\n    },\n    attribute: {\n      pattern: /#!?\\[(?:[^\\[\\]"]|"(?:\\\\[\\s\\S]|[^\\\\"])*")*\\]/,\n      greedy: !0,\n      alias: "attr-name",\n      inside: {\n        string: null\n      }\n    },\n    "closure-params": {\n      pattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        "closure-punctuation": {\n          pattern: /^\\||\\|$/,\n          alias: "punctuation"\n        },\n        rest: null\n      }\n    },\n    "lifetime-annotation": {\n      pattern: /\'\\w+/,\n      alias: "symbol"\n    },\n    "fragment-specifier": {\n      pattern: /(\\$\\w+:)[a-z]+/,\n      lookbehind: !0,\n      alias: "punctuation"\n    },\n    variable: /\\$\\w+/,\n    "function-definition": {\n      pattern: /(\\bfn\\s+)\\w+/,\n      lookbehind: !0,\n      alias: "function"\n    },\n    "type-definition": {\n      pattern: /(\\b(?:enum|struct|union)\\s+)\\w+/,\n      lookbehind: !0,\n      alias: "class-name"\n    },\n    "module-declaration": [{\n      pattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,\n      lookbehind: !0,\n      alias: "namespace"\n    }, {\n      pattern: /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\n      lookbehind: !0,\n      alias: "namespace",\n      inside: {\n        punctuation: /::/\n      }\n    }],\n    keyword: [/\\b(?:abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|Self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/, /\\b(?:[ui](?:8|16|32|64|128|size)|f(?:32|64)|bool|char|str)\\b/],\n    function: /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,\n    macro: {\n      pattern: /\\b\\w+!/,\n      alias: "property"\n    },\n    constant: /\\b[A-Z_][A-Z_\\d]+\\b/,\n    "class-name": /\\b[A-Z]\\w*\\b/,\n    namespace: {\n      pattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,\n      inside: {\n        punctuation: /::/\n      }\n    },\n    number: /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:[iu](?:8|16|32|64|size)?|f32|f64))?\\b/,\n    boolean: /\\b(?:false|true)\\b/,\n    punctuation: /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n    operator: /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n  }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;\n}(Prism);\n!function (e) {\n  e.languages.sass = e.languages.extend("css", {\n    comment: {\n      pattern: /^([ \\t]*)\\/[\\/*].*(?:(?:\\r?\\n|\\r)\\1[ \\t].+)*/m,\n      lookbehind: !0,\n      greedy: !0\n    }\n  }), e.languages.insertBefore("sass", "atrule", {\n    "atrule-line": {\n      pattern: /^(?:[ \\t]*)[@+=].+/m,\n      greedy: !0,\n      inside: {\n        atrule: /(?:@[\\w-]+|[+=])/m\n      }\n    }\n  }), delete e.languages.sass.atrule;\n  var r = /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/,\n      t = [/[+*\\/%]|[=!]=|<=?|>=?|\\b(?:and|or|not)\\b/, {\n    pattern: /(\\s)-(?=\\s)/,\n    lookbehind: !0\n  }];\n  e.languages.insertBefore("sass", "property", {\n    "variable-line": {\n      pattern: /^[ \\t]*\\$.+/m,\n      greedy: !0,\n      inside: {\n        punctuation: /:/,\n        variable: r,\n        operator: t\n      }\n    },\n    "property-line": {\n      pattern: /^[ \\t]*(?:[^:\\s]+ *:.*|:[^:\\s].*)/m,\n      greedy: !0,\n      inside: {\n        property: [/[^:\\s]+(?=\\s*:)/, {\n          pattern: /(:)[^:\\s]+/,\n          lookbehind: !0\n        }],\n        punctuation: /:/,\n        variable: r,\n        operator: t,\n        important: e.languages.sass.important\n      }\n    }\n  }), delete e.languages.sass.property, delete e.languages.sass.important, e.languages.insertBefore("sass", "punctuation", {\n    selector: {\n      pattern: /^([ \\t]*)\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*(?:,(?:\\r?\\n|\\r)\\1[ \\t]+\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*)*/m,\n      lookbehind: !0,\n      greedy: !0\n    }\n  });\n}(Prism);\nPrism.languages.scss = Prism.languages.extend("css", {\n  comment: {\n    pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n    lookbehind: !0\n  },\n  atrule: {\n    pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n    inside: {\n      rule: /@[\\w-]+/\n    }\n  },\n  url: /(?:[-a-z]+-)?url(?=\\()/i,\n  selector: {\n    pattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/m,\n    inside: {\n      parent: {\n        pattern: /&/,\n        alias: "important"\n      },\n      placeholder: /%[-\\w]+/,\n      variable: /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n    }\n  },\n  property: {\n    pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n    inside: {\n      variable: /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n    }\n  }\n}), Prism.languages.insertBefore("scss", "atrule", {\n  keyword: [/@(?:if|else(?: if)?|forward|for|each|while|import|use|extend|debug|warn|mixin|include|function|return|content)\\b/i, {\n    pattern: /( )(?:from|through)(?= )/,\n    lookbehind: !0\n  }]\n}), Prism.languages.insertBefore("scss", "important", {\n  variable: /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n}), Prism.languages.insertBefore("scss", "function", {\n  "module-modifier": {\n    pattern: /\\b(?:as|with|show|hide)\\b/i,\n    alias: "keyword"\n  },\n  placeholder: {\n    pattern: /%[-\\w]+/,\n    alias: "selector"\n  },\n  statement: {\n    pattern: /\\B!(?:default|optional)\\b/i,\n    alias: "keyword"\n  },\n  boolean: /\\b(?:true|false)\\b/,\n  null: {\n    pattern: /\\bnull\\b/,\n    alias: "keyword"\n  },\n  operator: {\n    pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|or|not)(?=\\s)/,\n    lookbehind: !0\n  }\n}), Prism.languages.scss.atrule.inside.rest = Prism.languages.scss;\nPrism.languages.scala = Prism.languages.extend("java", {\n  "triple-quoted-string": {\n    pattern: /"""[\\s\\S]*?"""/,\n    greedy: !0,\n    alias: "string"\n  },\n  string: {\n    pattern: /("|\')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: !0\n  },\n  keyword: /<-|=>|\\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\\b/,\n  number: /\\b0x(?:[\\da-f]*\\.)?[\\da-f]+|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e\\d+)?[dfl]?/i,\n  builtin: /\\b(?:String|Int|Long|Short|Byte|Boolean|Double|Float|Char|Any|AnyRef|AnyVal|Unit|Nothing)\\b/,\n  symbol: /\'[^\\d\\s\\\\]\\w*/\n}), delete Prism.languages.scala["class-name"], delete Prism.languages.scala.function;\nPrism.languages.scheme = {\n  comment: /;.*|#;\\s*(?:\\((?:[^()]|\\([^()]*\\))*\\)|\\[(?:[^\\[\\]]|\\[[^\\[\\]]*\\])*\\])|#\\|(?:[^#|]|#(?!\\|)|\\|(?!#)|#\\|(?:[^#|]|#(?!\\|)|\\|(?!#))*\\|#)*\\|#/,\n  string: {\n    pattern: /"(?:[^"\\\\]|\\\\.)*"/,\n    greedy: !0\n  },\n  symbol: {\n    pattern: /\'[^()\\[\\]#\'\\s]+/,\n    greedy: !0\n  },\n  character: {\n    pattern: /#\\\\(?:[ux][a-fA-F\\d]+\\b|[-a-zA-Z]+\\b|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|\\S)/,\n    greedy: !0,\n    alias: "string"\n  },\n  "lambda-parameter": [{\n    pattern: /((?:^|[^\'`#])[(\\[]lambda\\s+)(?:[^|()\\[\\]\'\\s]+|\\|(?:[^\\\\|]|\\\\.)*\\|)/,\n    lookbehind: !0\n  }, {\n    pattern: /((?:^|[^\'`#])[(\\[]lambda\\s+[(\\[])[^()\\[\\]\']+/,\n    lookbehind: !0\n  }],\n  keyword: {\n    pattern: /((?:^|[^\'`#])[(\\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|export|except|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\\*)?|let\\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\\[\\]\\s]|$)/,\n    lookbehind: !0\n  },\n  builtin: {\n    pattern: /((?:^|[^\'`#])[(\\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\\?|boolean=?\\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\\?|\\?|<\\?|<=\\?|=\\?|>\\?|>=\\?)|close-(?:input-port|output-port|port)|complex\\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\\??|eq\\?|equal\\?|eqv\\?|error|error-object(?:-irritants|-message|\\?)|eval|even\\?|exact(?:-integer-sqrt|-integer\\?|\\?)?|expt|features|file-error\\?|floor(?:-quotient|-remainder|\\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\\??|input-port(?:-open\\?|\\?)|integer(?:->char|\\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\\?|newline|not|null\\?|number(?:->string|\\?)|numerator|odd\\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\\?|\\?)|pair\\?|peek-char|peek-u8|port\\?|positive\\?|procedure\\?|quotient|raise|raise-continuable|rational\\?|rationalize|read-(?:bytevector|bytevector!|char|error\\?|line|string|u8)|real\\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\\?|<\\?|<=\\?|=\\?|>\\?|>=\\?)?|substring|symbol(?:->string|\\?|=\\?)|syntax-error|textual-port\\?|truncate(?:-quotient|-remainder|\\/)?|u8-ready\\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\\?)(?=[()\\[\\]\\s]|$)/,\n    lookbehind: !0\n  },\n  operator: {\n    pattern: /((?:^|[^\'`#])[(\\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\\[\\]\\s]|$)/,\n    lookbehind: !0\n  },\n  number: {\n    pattern: RegExp(function (r) {\n      for (var e in r) {\n        r[e] = r[e].replace(/<[\\w\\s]+>/g, function (e) {\n          return "(?:" + r[e].trim() + ")";\n        });\n      }\n\n      return r[e];\n    }({\n      "<ureal dec>": "\\\\d+(?:/\\\\d+)|(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:e[+-]?\\\\d+)?",\n      "<real dec>": "[+-]?<ureal dec>|[+-](?:inf|nan)\\\\.0",\n      "<imaginary dec>": "[+-](?:<ureal dec>|(?:inf|nan)\\\\.0)?i",\n      "<complex dec>": "<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>",\n      "<num dec>": "(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>",\n      "<ureal box>": "[0-9a-f]+(?:/[0-9a-f]+)?",\n      "<real box>": "[+-]?<ureal box>|[+-](?:inf|nan)\\\\.0",\n      "<imaginary box>": "[+-](?:<ureal box>|(?:inf|nan)\\\\.0)?i",\n      "<complex box>": "<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>",\n      "<num box>": "#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>",\n      "<number>": "(^|[()\\\\[\\\\]\\\\s])(?:<num dec>|<num box>)(?=[()\\\\[\\\\]\\\\s]|$)"\n    }), "i"),\n    lookbehind: !0\n  },\n  boolean: {\n    pattern: /(^|[()\\[\\]\\s])#(?:[ft]|false|true)(?=[()\\[\\]\\s]|$)/,\n    lookbehind: !0\n  },\n  function: {\n    pattern: /((?:^|[^\'`#])[(\\[])(?:[^|()\\[\\]\'\\s]+|\\|(?:[^\\\\|]|\\\\.)*\\|)(?=[()\\[\\]\\s]|$)/,\n    lookbehind: !0\n  },\n  identifier: {\n    pattern: /(^|[()\\[\\]\\s])\\|(?:[^\\\\|]|\\\\.)*\\|(?=[()\\[\\]\\s]|$)/,\n    lookbehind: !0,\n    greedy: !0\n  },\n  punctuation: /[()\\[\\]\']/\n};\nPrism.languages.sql = {\n  comment: {\n    pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n    lookbehind: !0\n  },\n  variable: [{\n    pattern: /@(["\'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n    greedy: !0\n  }, /@[\\w.$]+/],\n  string: {\n    pattern: /(^|[^@\\\\])("|\')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n    greedy: !0,\n    lookbehind: !0\n  },\n  function: /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i,\n  keyword: /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:S|ING)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n  boolean: /\\b(?:TRUE|FALSE|NULL)\\b/i,\n  number: /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n  operator: /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|IN|ILIKE|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n  punctuation: /[;[\\]()`,.]/\n};\n!function (e) {\n  var n = {\n    pattern: /(\\b\\d+)(?:%|[a-z]+)/,\n    lookbehind: !0\n  },\n      r = {\n    pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n    lookbehind: !0\n  },\n      t = {\n    comment: {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: !0\n    },\n    url: {\n      pattern: /\\burl\\((["\']?).*?\\1\\)/i,\n      greedy: !0\n    },\n    string: {\n      pattern: /("|\')(?:(?!\\1)[^\\\\\\r\\n]|\\\\(?:\\r\\n|[\\s\\S]))*\\1/,\n      greedy: !0\n    },\n    interpolation: null,\n    func: null,\n    important: /\\B!(?:important|optional)\\b/i,\n    keyword: {\n      pattern: /(^|\\s+)(?:(?:if|else|for|return|unless)(?=\\s|$)|@[\\w-]+)/,\n      lookbehind: !0\n    },\n    hexcode: /#[\\da-f]{3,6}/i,\n    color: [/\\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\\b/i, {\n      pattern: /\\b(?:rgb|hsl)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:rgb|hsl)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n      inside: {\n        unit: n,\n        number: r,\n        function: /[\\w-]+(?=\\()/,\n        punctuation: /[(),]/\n      }\n    }],\n    entity: /\\\\[\\da-f]{1,8}/i,\n    unit: n,\n    boolean: /\\b(?:true|false)\\b/,\n    operator: [/~|[+!\\/%<>?=]=?|[-:]=|\\*[*=]?|\\.{2,3}|&&|\\|\\||\\B-\\B|\\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\\b/],\n    number: r,\n    punctuation: /[{}()\\[\\];:,]/\n  };\n  t.interpolation = {\n    pattern: /\\{[^\\r\\n}:]+\\}/,\n    alias: "variable",\n    inside: {\n      delimiter: {\n        pattern: /^\\{|\\}$/,\n        alias: "punctuation"\n      },\n      rest: t\n    }\n  }, t.func = {\n    pattern: /[\\w-]+\\([^)]*\\).*/,\n    inside: {\n      function: /^[^(]+/,\n      rest: t\n    }\n  }, e.languages.stylus = {\n    "atrule-declaration": {\n      pattern: /(^[ \\t]*)@.+/m,\n      lookbehind: !0,\n      inside: {\n        atrule: /^@[\\w-]+/,\n        rest: t\n      }\n    },\n    "variable-declaration": {\n      pattern: /(^[ \\t]*)[\\w$-]+\\s*.?=[ \\t]*(?:\\{[^{}]*\\}|\\S.*|$)/m,\n      lookbehind: !0,\n      inside: {\n        variable: /^\\S+/,\n        rest: t\n      }\n    },\n    statement: {\n      pattern: /(^[ \\t]*)(?:if|else|for|return|unless)[ \\t].+/m,\n      lookbehind: !0,\n      inside: {\n        keyword: /^\\S+/,\n        rest: t\n      }\n    },\n    "property-declaration": {\n      pattern: /((?:^|\\{)([ \\t]*))(?:[\\w-]|\\{[^}\\r\\n]+\\})+(?:\\s*:\\s*|[ \\t]+)(?!\\s)[^{\\r\\n]*(?:;|[^{\\r\\n,]$(?!(?:\\r?\\n|\\r)(?:\\{|\\2[ \\t])))/m,\n      lookbehind: !0,\n      inside: {\n        property: {\n          pattern: /^[^\\s:]+/,\n          inside: {\n            interpolation: t.interpolation\n          }\n        },\n        rest: t\n      }\n    },\n    selector: {\n      pattern: /(^[ \\t]*)(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)(?:(?:\\r?\\n|\\r)(?:\\1(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)))*(?:,$|\\{|(?=(?:\\r?\\n|\\r)(?:\\{|\\1[ \\t])))/m,\n      lookbehind: !0,\n      inside: {\n        interpolation: t.interpolation,\n        comment: t.comment,\n        punctuation: /[{},]/\n      }\n    },\n    func: t.func,\n    string: t.string,\n    comment: {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: !0,\n      greedy: !0\n    },\n    interpolation: t.interpolation,\n    punctuation: /[{}()\\[\\];:.]/\n  };\n}(Prism);\nPrism.languages.swift = {\n  comment: {\n    pattern: /(^|[^\\\\:])(?:\\/\\/.*|\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*\\*\\/)/,\n    lookbehind: !0,\n    greedy: !0\n  },\n  "string-literal": [{\n    pattern: RegExp(\'(^|[^"#])(?:"(?:\\\\\\\\(?:\\\\((?:[^()]|\\\\([^()]*\\\\))*\\\\)|\\r\\n|[^(])|[^\\\\\\\\\\r\\n"])*"|"""(?:\\\\\\\\(?:\\\\((?:[^()]|\\\\([^()]*\\\\))*\\\\)|[^(])|[^\\\\\\\\"]|"(?!""))*""")(?!["#])\'),\n    lookbehind: !0,\n    greedy: !0,\n    inside: {\n      interpolation: {\n        pattern: /(\\\\\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n        lookbehind: !0,\n        inside: null\n      },\n      "interpolation-punctuation": {\n        pattern: /^\\)|\\\\\\($/,\n        alias: "punctuation"\n      },\n      punctuation: /\\\\(?=[\\r\\n])/,\n      string: /[\\s\\S]+/\n    }\n  }, {\n    pattern: RegExp(\'(^|[^"#])(#+)(?:"(?:\\\\\\\\(?:#+\\\\((?:[^()]|\\\\([^()]*\\\\))*\\\\)|\\r\\n|[^#])|[^\\\\\\\\\\r\\n])*?"|"""(?:\\\\\\\\(?:#+\\\\((?:[^()]|\\\\([^()]*\\\\))*\\\\)|[^#])|[^\\\\\\\\])*?""")\\\\2\'),\n    lookbehind: !0,\n    greedy: !0,\n    inside: {\n      interpolation: {\n        pattern: /(\\\\#+\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n        lookbehind: !0,\n        inside: null\n      },\n      "interpolation-punctuation": {\n        pattern: /^\\)|\\\\#+\\($/,\n        alias: "punctuation"\n      },\n      string: /[\\s\\S]+/\n    }\n  }],\n  directive: {\n    pattern: RegExp("#(?:(?:elseif|if)\\\\b(?:[ \\t]*(?:![ \\t]*)?(?:\\\\b\\\\w+\\\\b(?:[ \\t]*\\\\((?:[^()]|\\\\([^()]*\\\\))*\\\\))?|\\\\((?:[^()]|\\\\([^()]*\\\\))*\\\\))(?:[ \\t]*(?:&&|\\\\|\\\\|))?)+|(?:else|endif)\\\\b)"),\n    alias: "property",\n    inside: {\n      "directive-name": /^#\\w+/,\n      boolean: /\\b(?:true|false)\\b/,\n      number: /\\b\\d+(?:\\.\\d+)*\\b/,\n      operator: /!|&&|\\|\\||[<>]=?/,\n      punctuation: /[(),]/\n    }\n  },\n  literal: {\n    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\\b/,\n    alias: "constant"\n  },\n  "other-directive": {\n    pattern: /#\\w+\\b/,\n    alias: "property"\n  },\n  attribute: {\n    pattern: /@\\w+/,\n    alias: "atrule"\n  },\n  "function-definition": {\n    pattern: /(\\bfunc\\s+)\\w+/,\n    lookbehind: !0,\n    alias: "function"\n  },\n  label: {\n    pattern: /\\b(break|continue)\\s+\\w+|\\b[a-zA-Z_]\\w*(?=\\s*:\\s*(?:for|repeat|while)\\b)/,\n    lookbehind: !0,\n    alias: "important"\n  },\n  keyword: /\\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\\b/,\n  boolean: /\\b(?:true|false)\\b/,\n  nil: {\n    pattern: /\\bnil\\b/,\n    alias: "constant"\n  },\n  "short-argument": /\\$\\d+\\b/,\n  omit: {\n    pattern: /\\b_\\b/,\n    alias: "keyword"\n  },\n  number: /\\b(?:[\\d_]+(?:\\.[\\de_]+)?|0x[a-f0-9_]+(?:\\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b/i,\n  "class-name": /\\b[A-Z](?:[A-Z_\\d]*[a-z]\\w*)?\\b/,\n  function: /\\b[a-z_]\\w*(?=\\s*\\()/i,\n  constant: /\\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\\b/,\n  operator: /[-+*/%=!<>&|^~?]+|\\.[.\\-+*/%=!<>&|^~?]+/,\n  punctuation: /[{}[\\]();,.:\\\\]/\n}, Prism.languages.swift["string-literal"].forEach(function (e) {\n  e.inside.interpolation.inside = Prism.languages.swift;\n});\n!function (n) {\n  function e(n, e) {\n    return RegExp(n.replace(/<MOD>/g, function () {\n      return "(?:\\\\([^|()\\n]+\\\\)|\\\\[[^\\\\]\\n]+\\\\]|\\\\{[^}\\n]+\\\\})";\n    }).replace(/<PAR>/g, function () {\n      return "(?:\\\\)|\\\\((?![^|()\\n]+\\\\)))";\n    }), e || "");\n  }\n\n  var i = {\n    css: {\n      pattern: /\\{[^{}]+\\}/,\n      inside: {\n        rest: n.languages.css\n      }\n    },\n    "class-id": {\n      pattern: /(\\()[^()]+(?=\\))/,\n      lookbehind: !0,\n      alias: "attr-value"\n    },\n    lang: {\n      pattern: /(\\[)[^\\[\\]]+(?=\\])/,\n      lookbehind: !0,\n      alias: "attr-value"\n    },\n    punctuation: /[\\\\\\/]\\d+|\\S/\n  },\n      t = n.languages.textile = n.languages.extend("markup", {\n    phrase: {\n      pattern: /(^|\\r|\\n)\\S[\\s\\S]*?(?=$|\\r?\\n\\r?\\n|\\r\\r)/,\n      lookbehind: !0,\n      inside: {\n        "block-tag": {\n          pattern: e("^[a-z]\\\\w*(?:<MOD>|<PAR>|[<>=])*\\\\."),\n          inside: {\n            modifier: {\n              pattern: e("(^[a-z]\\\\w*)(?:<MOD>|<PAR>|[<>=])+(?=\\\\.)"),\n              lookbehind: !0,\n              inside: i\n            },\n            tag: /^[a-z]\\w*/,\n            punctuation: /\\.$/\n          }\n        },\n        list: {\n          pattern: e("^[*#]+<MOD>*\\\\s+\\\\S.*", "m"),\n          inside: {\n            modifier: {\n              pattern: e("(^[*#]+)<MOD>+"),\n              lookbehind: !0,\n              inside: i\n            },\n            punctuation: /^[*#]+/\n          }\n        },\n        table: {\n          pattern: e("^(?:(?:<MOD>|<PAR>|[<>=^~])+\\\\.\\\\s*)?(?:\\\\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\\\\\\\/]\\\\d+)+\\\\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\\\\\\\/]\\\\d+)+\\\\.))[^|]*)+\\\\|", "m"),\n          inside: {\n            modifier: {\n              pattern: e("(^|\\\\|(?:\\r?\\n|\\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\\\\\\\/]\\\\d+)+(?=\\\\.)"),\n              lookbehind: !0,\n              inside: i\n            },\n            punctuation: /\\||^\\./\n          }\n        },\n        inline: {\n          pattern: e("(^|[^a-zA-Z\\\\d])(\\\\*\\\\*|__|\\\\?\\\\?|[*_%@+\\\\-^~])<MOD>*.+?\\\\2(?![a-zA-Z\\\\d])"),\n          lookbehind: !0,\n          inside: {\n            bold: {\n              pattern: e("(^(\\\\*\\\\*?)<MOD>*).+?(?=\\\\2)"),\n              lookbehind: !0\n            },\n            italic: {\n              pattern: e("(^(__?)<MOD>*).+?(?=\\\\2)"),\n              lookbehind: !0\n            },\n            cite: {\n              pattern: e("(^\\\\?\\\\?<MOD>*).+?(?=\\\\?\\\\?)"),\n              lookbehind: !0,\n              alias: "string"\n            },\n            code: {\n              pattern: e("(^@<MOD>*).+?(?=@)"),\n              lookbehind: !0,\n              alias: "keyword"\n            },\n            inserted: {\n              pattern: e("(^\\\\+<MOD>*).+?(?=\\\\+)"),\n              lookbehind: !0\n            },\n            deleted: {\n              pattern: e("(^-<MOD>*).+?(?=-)"),\n              lookbehind: !0\n            },\n            span: {\n              pattern: e("(^%<MOD>*).+?(?=%)"),\n              lookbehind: !0\n            },\n            modifier: {\n              pattern: e("(^\\\\*\\\\*|__|\\\\?\\\\?|[*_%@+\\\\-^~])<MOD>+"),\n              lookbehind: !0,\n              inside: i\n            },\n            punctuation: /[*_%?@+\\-^~]+/\n          }\n        },\n        "link-ref": {\n          pattern: /^\\[[^\\]]+\\]\\S+$/m,\n          inside: {\n            string: {\n              pattern: /(^\\[)[^\\]]+(?=\\])/,\n              lookbehind: !0\n            },\n            url: {\n              pattern: /(^\\])\\S+$/,\n              lookbehind: !0\n            },\n            punctuation: /[\\[\\]]/\n          }\n        },\n        link: {\n          pattern: e(\'"<MOD>*[^"]+":.+?(?=[^\\\\w/]?(?:\\\\s|$))\'),\n          inside: {\n            text: {\n              pattern: e(\'(^"<MOD>*)[^"]+(?=")\'),\n              lookbehind: !0\n            },\n            modifier: {\n              pattern: e(\'(^")<MOD>+\'),\n              lookbehind: !0,\n              inside: i\n            },\n            url: {\n              pattern: /(:).+/,\n              lookbehind: !0\n            },\n            punctuation: /[":]/\n          }\n        },\n        image: {\n          pattern: e("!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\\\\s()]+(?:\\\\([^)]+\\\\))?!(?::.+?(?=[^\\\\w/]?(?:\\\\s|$)))?"),\n          inside: {\n            source: {\n              pattern: e("(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\\\\s()]+(?:\\\\([^)]+\\\\))?(?=!)"),\n              lookbehind: !0,\n              alias: "url"\n            },\n            modifier: {\n              pattern: e("(^!)(?:<MOD>|<PAR>|[<>=])+"),\n              lookbehind: !0,\n              inside: i\n            },\n            url: {\n              pattern: /(:).+/,\n              lookbehind: !0\n            },\n            punctuation: /[!:]/\n          }\n        },\n        footnote: {\n          pattern: /\\b\\[\\d+\\]/,\n          alias: "comment",\n          inside: {\n            punctuation: /\\[|\\]/\n          }\n        },\n        acronym: {\n          pattern: /\\b[A-Z\\d]+\\([^)]+\\)/,\n          inside: {\n            comment: {\n              pattern: /(\\()[^()]+(?=\\))/,\n              lookbehind: !0\n            },\n            punctuation: /[()]/\n          }\n        },\n        mark: {\n          pattern: /\\b\\((?:TM|R|C)\\)/,\n          alias: "comment",\n          inside: {\n            punctuation: /[()]/\n          }\n        }\n      }\n    }\n  }),\n      a = t.phrase.inside,\n      o = {\n    inline: a.inline,\n    link: a.link,\n    image: a.image,\n    footnote: a.footnote,\n    acronym: a.acronym,\n    mark: a.mark\n  };\n  t.tag.pattern = /<\\/?(?!\\d)[a-z0-9]+(?:\\s+[^\\s>\\/=]+(?:=(?:("|\')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s\'">=]+))?)*\\s*\\/?>/i;\n  var r = a.inline.inside;\n  r.bold.inside = o, r.italic.inside = o, r.inserted.inside = o, r.deleted.inside = o, r.span.inside = o;\n  var d = a.table.inside;\n  d.inline = o.inline, d.link = o.link, d.image = o.image, d.footnote = o.footnote, d.acronym = o.acronym, d.mark = o.mark;\n}(Prism);\n!function (e) {\n  function n(e) {\n    return e.replace(/__/g, function () {\n      return "(?:[\\\\w-]+|\'[^\'\\n\\r]*\'|\\"(?:\\\\\\\\.|[^\\\\\\\\\\"\\r\\n])*\\")";\n    });\n  }\n\n  e.languages.toml = {\n    comment: {\n      pattern: /#.*/,\n      greedy: !0\n    },\n    table: {\n      pattern: RegExp(n("(^[\\t ]*\\\\[\\\\s*(?:\\\\[\\\\s*)?)__(?:\\\\s*\\\\.\\\\s*__)*(?=\\\\s*\\\\])"), "m"),\n      lookbehind: !0,\n      greedy: !0,\n      alias: "class-name"\n    },\n    key: {\n      pattern: RegExp(n("(^[\\t ]*|[{,]\\\\s*)__(?:\\\\s*\\\\.\\\\s*__)*(?=\\\\s*=)"), "m"),\n      lookbehind: !0,\n      greedy: !0,\n      alias: "property"\n    },\n    string: {\n      pattern: /"""(?:\\\\[\\s\\S]|[^\\\\])*?"""|\'\'\'[\\s\\S]*?\'\'\'|\'[^\'\\n\\r]*\'|"(?:\\\\.|[^\\\\"\\r\\n])*"/,\n      greedy: !0\n    },\n    date: [{\n      pattern: /\\b\\d{4}-\\d{2}-\\d{2}(?:[T\\s]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})?)?\\b/i,\n      alias: "number"\n    }, {\n      pattern: /\\b\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?\\b/,\n      alias: "number"\n    }],\n    number: /(?:\\b0(?:x[\\da-zA-Z]+(?:_[\\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\\b|[-+]?\\b\\d+(?:_\\d+)*(?:\\.\\d+(?:_\\d+)*)?(?:[eE][+-]?\\d+(?:_\\d+)*)?\\b|[-+]?\\b(?:inf|nan)\\b/,\n    boolean: /\\b(?:true|false)\\b/,\n    punctuation: /[.,=[\\]{}]/\n  };\n}(Prism);\nPrism.languages.twig = {\n  comment: /\\{#[\\s\\S]*?#\\}/,\n  tag: {\n    pattern: /\\{\\{[\\s\\S]*?\\}\\}|\\{%[\\s\\S]*?%\\}/,\n    inside: {\n      ld: {\n        pattern: /^(?:\\{\\{-?|\\{%-?\\s*\\w+)/,\n        inside: {\n          punctuation: /^(?:\\{\\{|\\{%)-?/,\n          keyword: /\\w+/\n        }\n      },\n      rd: {\n        pattern: /-?(?:%\\}|\\}\\})$/,\n        inside: {\n          punctuation: /.+/\n        }\n      },\n      string: {\n        pattern: /("|\')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        inside: {\n          punctuation: /^[\'"]|[\'"]$/\n        }\n      },\n      keyword: /\\b(?:even|if|odd)\\b/,\n      boolean: /\\b(?:true|false|null)\\b/,\n      number: /\\b0x[\\dA-Fa-f]+|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee][-+]?\\d+)?/,\n      operator: [{\n        pattern: /(\\s)(?:and|b-and|b-xor|b-or|ends with|in|is|matches|not|or|same as|starts with)(?=\\s)/,\n        lookbehind: !0\n      }, /[=<>]=?|!=|\\*\\*?|\\/\\/?|\\?:?|[-+~%|]/],\n      property: /\\b[a-zA-Z_]\\w*\\b/,\n      punctuation: /[()\\[\\]{}:.,]/\n    }\n  },\n  other: {\n    pattern: /\\S(?:[\\s\\S]*\\S)?/,\n    inside: Prism.languages.markup\n  }\n};\nPrism.languages.vim = {\n  string: /"(?:[^"\\\\\\r\\n]|\\\\.)*"|\'(?:[^\'\\r\\n]|\'\')*\'/,\n  comment: /".*/,\n  function: /\\b\\w+(?=\\()/,\n  keyword: /\\b(?:ab|abbreviate|abc|abclear|abo|aboveleft|al|all|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|ar|args|argu|argument|as|ascii|bad|badd|ba|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bN|bNext|bo|botright|bp|bprevious|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|br|brewind|bro|browse|bufdo|b|buffer|buffers|bun|bunload|bw|bwipeout|ca|cabbrev|cabc|cabclear|caddb|caddbuffer|cad|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cgetb|cgetbuffer|cgete|cgetexpr|cg|cgetfile|c|change|changes|chd|chdir|che|checkpath|checkt|checktime|cla|clast|cl|clist|clo|close|cmapc|cmapclear|cnew|cnewer|cn|cnext|cN|cNext|cnf|cnfile|cNfcNfile|cnorea|cnoreabbrev|col|colder|colo|colorscheme|comc|comclear|comp|compiler|conf|confirm|con|continue|cope|copen|co|copy|cpf|cpfile|cp|cprevious|cq|cquit|cr|crewind|cuna|cunabbrev|cu|cunmap|cw|cwindow|debugg|debuggreedy|delc|delcommand|d|delete|delf|delfunction|delm|delmarks|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|di|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|earlier|echoe|echoerr|echom|echomsg|echon|e|edit|el|else|elsei|elseif|em|emenu|endfo|endfor|endf|endfunction|endfun|en|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fina|finally|fin|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|folddoc|folddoclosed|foldd|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|ha|hardcopy|h|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iuna|iunabbrev|iu|iunmap|j|join|ju|jumps|k|keepalt|keepj|keepjumps|kee|keepmarks|laddb|laddbuffer|lad|laddexpr|laddf|laddfile|lan|language|la|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|let|left|lefta|leftabove|lex|lexpr|lf|lfile|lfir|lfirst|lgetb|lgetbuffer|lgete|lgetexpr|lg|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|l|list|ll|lla|llast|lli|llist|lmak|lmake|lm|lmap|lmapc|lmapclear|lnew|lnewer|lne|lnext|lN|lNext|lnf|lnfile|lNf|lNfile|ln|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lpf|lpfile|lp|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|mak|make|ma|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkvie|mkview|mkv|mkvimrc|mod|mode|m|move|mzf|mzfile|mz|mzscheme|nbkey|new|n|next|N|Next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|omapc|omapclear|on|only|o|open|opt|options|ou|ounmap|pc|pclose|ped|pedit|pe|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|p|print|P|Print|profd|profdel|prof|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptN|ptNext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|pyf|pyfile|py|python|qa|qall|q|quit|quita|quitall|r|read|rec|recover|redi|redir|red|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|rub|ruby|rubyd|rubydo|rubyf|rubyfile|ru|runtime|rv|rviminfo|sal|sall|san|sandbox|sa|sargument|sav|saveas|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbN|sbNext|sbp|sbprevious|sbr|sbrewind|sb|sbuffer|scripte|scriptencoding|scrip|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sla|slast|sl|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sN|sNext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|sor|sort|so|source|spelld|spelldump|spe|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|sp|split|spr|sprevious|sre|srewind|sta|stag|startg|startgreplace|star|startinsert|startr|startreplace|stj|stjump|st|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tab|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabnew|tabn|tabnext|tabN|tabNext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|ta|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|tN|tNext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|una|unabbreviate|u|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|verb|verbose|ve|version|vert|vertical|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|vi|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|wa|wall|wh|while|winc|wincmd|windo|winp|winpos|win|winsize|wn|wnext|wN|wNext|wp|wprevious|wq|wqa|wqall|w|write|ws|wsverb|wv|wviminfo|X|xa|xall|x|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|XMLent|XMLns|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\\b/,\n  builtin: /\\b(?:autocmd|acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|t_AB|t_AF|t_al|t_AL|t_bc|t_cd|t_ce|t_Ce|t_cl|t_cm|t_Co|t_cs|t_Cs|t_CS|t_CV|t_da|t_db|t_dl|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_fs|t_IE|t_IS|t_k1|t_K1|t_k2|t_k3|t_K3|t_k4|t_K4|t_k5|t_K5|t_k6|t_K6|t_k7|t_K7|t_k8|t_K8|t_k9|t_K9|t_KA|t_kb|t_kB|t_KB|t_KC|t_kd|t_kD|t_KD|t_ke|t_KE|t_KF|t_KG|t_kh|t_KH|t_kI|t_KI|t_KJ|t_KK|t_kl|t_KL|t_kN|t_kP|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_RI|t_RV|t_Sb|t_se|t_Sf|t_SI|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_WP|t_WS|t_xs|t_ZH|t_ZR)\\b/,\n  number: /\\b(?:0x[\\da-f]+|\\d+(?:\\.\\d+)?)\\b/i,\n  operator: /\\|\\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\\/%?]|\\b(?:is(?:not)?)\\b/,\n  punctuation: /[{}[\\](),;:]/\n};\nPrism.languages["visual-basic"] = {\n  comment: {\n    pattern: /(?:[\'‘’]|REM\\b)(?:[^\\r\\n_]|_(?:\\r\\n?|\\n)?)*/i,\n    inside: {\n      keyword: /^REM/i\n    }\n  },\n  directive: {\n    pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:[^\\S\\r\\n]_[^\\S\\r\\n]*(?:\\r\\n?|\\n)|.)+/i,\n    alias: "comment",\n    greedy: !0\n  },\n  string: {\n    pattern: /\\$?["“”](?:["“”]{2}|[^"“”])*["“”]C?/i,\n    greedy: !0\n  },\n  date: {\n    pattern: /#[^\\S\\r\\n]*(?:\\d+([/-])\\d+\\1\\d+(?:[^\\S\\r\\n]+(?:\\d+[^\\S\\r\\n]*(?:AM|PM)|\\d+:\\d+(?::\\d+)?(?:[^\\S\\r\\n]*(?:AM|PM))?))?|\\d+[^\\S\\r\\n]*(?:AM|PM)|\\d+:\\d+(?::\\d+)?(?:[^\\S\\r\\n]*(?:AM|PM))?)[^\\S\\r\\n]*#/i,\n    alias: "builtin"\n  },\n  number: /(?:(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)(?:E[+-]?\\d+)?|&[HO][\\dA-F]+)(?:U?[ILS]|[FRD])?/i,\n  boolean: /\\b(?:True|False|Nothing)\\b/i,\n  keyword: /\\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Until|Xor)\\b/i,\n  operator: [/[+\\-*/\\\\^<=>&#@$%!]/, {\n    pattern: /([^\\S\\r\\n])_(?=[^\\S\\r\\n]*[\\r\\n])/,\n    lookbehind: !0\n  }],\n  punctuation: /[{}().,:?]/\n}, Prism.languages.vb = Prism.languages["visual-basic"], Prism.languages.vba = Prism.languages["visual-basic"];\nPrism.languages.wasm = {\n  comment: [/\\(;[\\s\\S]*?;\\)/, {\n    pattern: /;;.*/,\n    greedy: !0\n  }],\n  string: {\n    pattern: /"(?:\\\\[\\s\\S]|[^"\\\\])*"/,\n    greedy: !0\n  },\n  keyword: [{\n    pattern: /\\b(?:align|offset)=/,\n    inside: {\n      operator: /=/\n    }\n  }, {\n    pattern: /\\b(?:(?:f32|f64|i32|i64)(?:\\.(?:abs|add|and|ceil|clz|const|convert_[su]\\/i(?:32|64)|copysign|ctz|demote\\/f64|div(?:_[su])?|eqz?|extend_[su]\\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\\/f32|reinterpret\\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\\/f(?:32|64))?|wrap\\/i64|xor))?|memory\\.(?:grow|size))\\b/,\n    inside: {\n      punctuation: /\\./\n    }\n  }, /\\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\\b/],\n  variable: /\\$[\\w!#$%&\'*+\\-./:<=>?@\\\\^`|~]+/i,\n  number: /[+-]?\\b(?:\\d(?:_?\\d)*(?:\\.\\d(?:_?\\d)*)?(?:[eE][+-]?\\d(?:_?\\d)*)?|0x[\\da-fA-F](?:_?[\\da-fA-F])*(?:\\.[\\da-fA-F](?:_?[\\da-fA-D])*)?(?:[pP][+-]?\\d(?:_?\\d)*)?)\\b|\\binf\\b|\\bnan(?::0x[\\da-fA-F](?:_?[\\da-fA-D])*)?\\b/,\n  punctuation: /[()]/\n};\n!function (e) {\n  var n = /[*&][^\\s[\\]{},]+/,\n      r = /!(?:<[\\w\\-%#;/?:@&=+$,.!~*\'()[\\]]+>|(?:[a-zA-Z\\d-]*!)?[\\w\\-%#;/?:@&=+$.~*\'()]+)?/,\n      t = "(?:" + r.source + "(?:[ \\t]+" + n.source + ")?|" + n.source + "(?:[ \\t]+" + r.source + ")?)",\n      a = "(?:[^\\\\s\\\\x00-\\\\x08\\\\x0e-\\\\x1f!\\"#%&\'*,\\\\-:>?@[\\\\]`{|}\\\\x7f-\\\\x84\\\\x86-\\\\x9f\\\\ud800-\\\\udfff\\\\ufffe\\\\uffff]|[?:-]<PLAIN>)(?:[ \\t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*".replace(/<PLAIN>/g, function () {\n    return "[^\\\\s\\\\x00-\\\\x08\\\\x0e-\\\\x1f,[\\\\]{}\\\\x7f-\\\\x84\\\\x86-\\\\x9f\\\\ud800-\\\\udfff\\\\ufffe\\\\uffff]";\n  }),\n      d = "\\"(?:[^\\"\\\\\\\\\\r\\n]|\\\\\\\\.)*\\"|\'(?:[^\'\\\\\\\\\\r\\n]|\\\\\\\\.)*\'";\n\n  function o(e, n) {\n    n = (n || "").replace(/m/g, "") + "m";\n    var r = "([:\\\\-,[{]\\\\s*(?:\\\\s<<prop>>[ \\t]+)?)(?:<<value>>)(?=[ \\t]*(?:$|,|\\\\]|\\\\}|(?:[\\r\\n]\\\\s*)?#))".replace(/<<prop>>/g, function () {\n      return t;\n    }).replace(/<<value>>/g, function () {\n      return e;\n    });\n    return RegExp(r, n);\n  }\n\n  e.languages.yaml = {\n    scalar: {\n      pattern: RegExp("([\\\\-:]\\\\s*(?:\\\\s<<prop>>[ \\t]+)?[|>])[ \\t]*(?:((?:\\r?\\n|\\r)[ \\t]+)\\\\S[^\\r\\n]*(?:\\\\2[^\\r\\n]+)*)".replace(/<<prop>>/g, function () {\n        return t;\n      })),\n      lookbehind: !0,\n      alias: "string"\n    },\n    comment: /#.*/,\n    key: {\n      pattern: RegExp("((?:^|[:\\\\-,[{\\r\\n?])[ \\t]*(?:<<prop>>[ \\t]+)?)<<key>>(?=\\\\s*:\\\\s)".replace(/<<prop>>/g, function () {\n        return t;\n      }).replace(/<<key>>/g, function () {\n        return "(?:" + a + "|" + d + ")";\n      })),\n      lookbehind: !0,\n      greedy: !0,\n      alias: "atrule"\n    },\n    directive: {\n      pattern: /(^[ \\t]*)%.+/m,\n      lookbehind: !0,\n      alias: "important"\n    },\n    datetime: {\n      pattern: o("\\\\d{4}-\\\\d\\\\d?-\\\\d\\\\d?(?:[tT]|[ \\t]+)\\\\d\\\\d?:\\\\d{2}:\\\\d{2}(?:\\\\.\\\\d*)?(?:[ \\t]*(?:Z|[-+]\\\\d\\\\d?(?::\\\\d{2})?))?|\\\\d{4}-\\\\d{2}-\\\\d{2}|\\\\d\\\\d?:\\\\d{2}(?::\\\\d{2}(?:\\\\.\\\\d*)?)?"),\n      lookbehind: !0,\n      alias: "number"\n    },\n    boolean: {\n      pattern: o("true|false", "i"),\n      lookbehind: !0,\n      alias: "important"\n    },\n    null: {\n      pattern: o("null|~", "i"),\n      lookbehind: !0,\n      alias: "important"\n    },\n    string: {\n      pattern: o(d),\n      lookbehind: !0,\n      greedy: !0\n    },\n    number: {\n      pattern: o("[+-]?(?:0x[\\\\da-f]+|0o[0-7]+|(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:e[+-]?\\\\d+)?|\\\\.inf|\\\\.nan)", "i"),\n      lookbehind: !0\n    },\n    tag: r,\n    important: n,\n    punctuation: /---|[:[\\]{}\\-,|>?]|\\.\\.\\./\n  }, e.languages.yml = e.languages.yaml;\n}(Prism);\n!function () {\n  if ("undefined" != typeof Prism && "undefined" != typeof document && document.querySelector) {\n    var t,\n        o = "line-numbers",\n        s = "linkable-line-numbers",\n        a = function a() {\n      if (void 0 === t) {\n        var e = document.createElement("div");\n        e.style.fontSize = "13px", e.style.lineHeight = "1.5", e.style.padding = "0", e.style.border = "0", e.innerHTML = "&nbsp;<br />&nbsp;", document.body.appendChild(e), t = 38 === e.offsetHeight, document.body.removeChild(e);\n      }\n\n      return t;\n    },\n        l = !0,\n        u = 0;\n\n    Prism.hooks.add("before-sanity-check", function (e) {\n      var t = e.element.parentElement;\n\n      if (c(t)) {\n        var n = 0;\n        v(".line-highlight", t).forEach(function (e) {\n          n += e.textContent.length, e.parentNode.removeChild(e);\n        }), n && /^(?: \\n)+$/.test(e.code.slice(-n)) && (e.code = e.code.slice(0, -n));\n      }\n    }), Prism.hooks.add("complete", function e(t) {\n      var n = t.element.parentElement;\n\n      if (c(n)) {\n        clearTimeout(u);\n        var i = Prism.plugins.lineNumbers,\n            r = t.plugins && t.plugins.lineNumbers;\n        if (y(n, o) && i && !r) Prism.hooks.add("line-numbers", e);else d(n)(), u = setTimeout(f, 1);\n      }\n    }), window.addEventListener("hashchange", f), window.addEventListener("resize", function () {\n      v("pre").filter(c).map(function (e) {\n        return d(e);\n      }).forEach(b);\n    });\n  }\n\n  function v(e, t) {\n    return Array.prototype.slice.call((t || document).querySelectorAll(e));\n  }\n\n  function y(e, t) {\n    return e.classList.contains(t);\n  }\n\n  function b(e) {\n    e();\n  }\n\n  function c(e) {\n    return !(!e || !/pre/i.test(e.nodeName)) && (!!e.hasAttribute("data-line") || !(!e.id || !Prism.util.isActive(e, s)));\n  }\n\n  function d(u, e, c) {\n    var t = (e = "string" == typeof e ? e : u.getAttribute("data-line") || "").replace(/\\s+/g, "").split(",").filter(Boolean),\n        d = +u.getAttribute("data-line-offset") || 0,\n        f = (a() ? parseInt : parseFloat)(getComputedStyle(u).lineHeight),\n        p = Prism.util.isActive(u, o),\n        n = u.querySelector("code"),\n        h = p ? u : n || u,\n        m = [],\n        g = n && h != n ? function (e, t) {\n      var n = getComputedStyle(e),\n          i = getComputedStyle(t);\n\n      function r(e) {\n        return +e.substr(0, e.length - 2);\n      }\n\n      return t.offsetTop + r(i.borderTopWidth) + r(i.paddingTop) - r(n.paddingTop);\n    }(u, n) : 0;\n    t.forEach(function (e) {\n      var t = e.split("-"),\n          n = +t[0],\n          i = +t[1] || n,\n          r = u.querySelector(\'.line-highlight[data-range="\' + e + \'"]\') || document.createElement("div");\n\n      if (m.push(function () {\n        r.setAttribute("aria-hidden", "true"), r.setAttribute("data-range", e), r.className = (c || "") + " line-highlight";\n      }), p && Prism.plugins.lineNumbers) {\n        var o = Prism.plugins.lineNumbers.getLine(u, n),\n            s = Prism.plugins.lineNumbers.getLine(u, i);\n\n        if (o) {\n          var a = o.offsetTop + g + "px";\n          m.push(function () {\n            r.style.top = a;\n          });\n        }\n\n        if (s) {\n          var l = s.offsetTop - o.offsetTop + s.offsetHeight + "px";\n          m.push(function () {\n            r.style.height = l;\n          });\n        }\n      } else m.push(function () {\n        r.setAttribute("data-start", String(n)), n < i && r.setAttribute("data-end", String(i)), r.style.top = (n - d - 1) * f + g + "px", r.textContent = new Array(i - n + 2).join(" \\n");\n      });\n\n      m.push(function () {\n        r.style.width = u.scrollWidth + "px";\n      }), m.push(function () {\n        h.appendChild(r);\n      });\n    });\n    var i = u.id;\n\n    if (p && Prism.util.isActive(u, s) && i) {\n      y(u, s) || m.push(function () {\n        u.classList.add(s);\n      });\n      var r = parseInt(u.getAttribute("data-start") || "1");\n      v(".line-numbers-rows > span", u).forEach(function (e, t) {\n        var n = t + r;\n\n        e.onclick = function () {\n          var e = i + "." + n;\n          l = !1, location.hash = e, setTimeout(function () {\n            l = !0;\n          }, 1);\n        };\n      });\n    }\n\n    return function () {\n      m.forEach(b);\n    };\n  }\n\n  function f() {\n    var e = location.hash.slice(1);\n    v(".temporary.line-highlight").forEach(function (e) {\n      e.parentNode.removeChild(e);\n    });\n    var t = (e.match(/\\.([\\d,-]+)$/) || [, ""])[1];\n\n    if (t && !document.getElementById(e)) {\n      var n = e.slice(0, e.lastIndexOf(".")),\n          i = document.getElementById(n);\n      if (i) i.hasAttribute("data-line") || i.setAttribute("data-line", ""), d(i, t, "temporary ")(), l && document.querySelector(".temporary.line-highlight").scrollIntoView();\n    }\n  }\n}();\n!function () {\n  if ("undefined" != typeof Prism && "undefined" != typeof document) {\n    var o = "line-numbers",\n        a = /\\n(?!$)/g,\n        e = Prism.plugins.lineNumbers = {\n      getLine: function getLine(e, n) {\n        if ("PRE" === e.tagName && e.classList.contains(o)) {\n          var t = e.querySelector(".line-numbers-rows");\n\n          if (t) {\n            var i = parseInt(e.getAttribute("data-start"), 10) || 1,\n                r = i + (t.children.length - 1);\n            n < i && (n = i), r < n && (n = r);\n            var s = n - i;\n            return t.children[s];\n          }\n        }\n      },\n      resize: function resize(e) {\n        u([e]);\n      },\n      assumeViewportIndependence: !0\n    },\n        n = void 0;\n    window.addEventListener("resize", function () {\n      e.assumeViewportIndependence && n === window.innerWidth || (n = window.innerWidth, u(Array.prototype.slice.call(document.querySelectorAll("pre." + o))));\n    }), Prism.hooks.add("complete", function (e) {\n      if (e.code) {\n        var n = e.element,\n            t = n.parentNode;\n\n        if (t && /pre/i.test(t.nodeName) && !n.querySelector(".line-numbers-rows") && Prism.util.isActive(n, o)) {\n          n.classList.remove(o), t.classList.add(o);\n          var i,\n              r = e.code.match(a),\n              s = r ? r.length + 1 : 1,\n              l = new Array(s + 1).join("<span></span>");\n          (i = document.createElement("span")).setAttribute("aria-hidden", "true"), i.className = "line-numbers-rows", i.innerHTML = l, t.hasAttribute("data-start") && (t.style.counterReset = "linenumber " + (parseInt(t.getAttribute("data-start"), 10) - 1)), e.element.appendChild(i), u([t]), Prism.hooks.run("line-numbers", e);\n        }\n      }\n    }), Prism.hooks.add("line-numbers", function (e) {\n      e.plugins = e.plugins || {}, e.plugins.lineNumbers = !0;\n    });\n  }\n\n  function u(e) {\n    if (0 != (e = e.filter(function (e) {\n      var n = function (e) {\n        return e ? window.getComputedStyle ? getComputedStyle(e) : e.currentStyle || null : null;\n      }(e)["white-space"];\n\n      return "pre-wrap" === n || "pre-line" === n;\n    })).length) {\n      var n = e.map(function (e) {\n        var n = e.querySelector("code"),\n            t = e.querySelector(".line-numbers-rows");\n\n        if (n && t) {\n          var i = e.querySelector(".line-numbers-sizer"),\n              r = n.textContent.split(a);\n          i || ((i = document.createElement("span")).className = "line-numbers-sizer", n.appendChild(i)), i.innerHTML = "0", i.style.display = "block";\n          var s = i.getBoundingClientRect().height;\n          return i.innerHTML = "", {\n            element: e,\n            lines: r,\n            lineHeights: [],\n            oneLinerHeight: s,\n            sizer: i\n          };\n        }\n      }).filter(Boolean);\n      n.forEach(function (e) {\n        var i = e.sizer,\n            n = e.lines,\n            r = e.lineHeights,\n            s = e.oneLinerHeight;\n        r[n.length - 1] = void 0, n.forEach(function (e, n) {\n          if (e && 1 < e.length) {\n            var t = i.appendChild(document.createElement("span"));\n            t.style.display = "block", t.textContent = e;\n          } else r[n] = s;\n        });\n      }), n.forEach(function (e) {\n        for (var n = e.sizer, t = e.lineHeights, i = 0, r = 0; r < t.length; r++) {\n          void 0 === t[r] && (t[r] = n.children[i++].getBoundingClientRect().height);\n        }\n      }), n.forEach(function (e) {\n        var n = e.sizer,\n            t = e.element.querySelector(".line-numbers-rows");\n        n.style.display = "none", n.innerHTML = "", e.lineHeights.forEach(function (e, n) {\n          t.children[n].style.height = e + "px";\n        });\n      });\n    }\n  }\n}();\n!function () {\n  if ("undefined" != typeof Prism && "undefined" != typeof document) {\n    var s = [];\n    t(function (t) {\n      if (t && t.meta && t.data) {\n        if (t.meta.status && 400 <= t.meta.status) return "Error: " + (t.data.message || t.meta.status);\n        if ("string" == typeof t.data.content) return "function" == typeof atob ? atob(t.data.content.replace(/\\s/g, "")) : "Your browser cannot decode base64";\n      }\n\n      return null;\n    }, "github"), t(function (t, e) {\n      if (t && t.meta && t.data && t.data.files) {\n        if (t.meta.status && 400 <= t.meta.status) return "Error: " + (t.data.message || t.meta.status);\n        var n = t.data.files,\n            a = e.getAttribute("data-filename");\n        if (null == a) for (var r in n) {\n          if (n.hasOwnProperty(r)) {\n            a = r;\n            break;\n          }\n        }\n        return void 0 !== n[a] ? n[a].content : "Error: unknown or missing gist file " + a;\n      }\n\n      return null;\n    }, "gist"), t(function (t) {\n      return t && t.node && "string" == typeof t.data ? t.data : null;\n    }, "bitbucket");\n    var f = 0,\n        d = "data-jsonp-status",\n        l = "loading",\n        c = "loaded",\n        m = "failed",\n        p = "pre[data-jsonp]:not([" + d + \'="\' + c + \'"]):not([\' + d + \'="\' + l + \'"])\';\n    Prism.hooks.add("before-highlightall", function (t) {\n      t.selector += ", " + p;\n    }), Prism.hooks.add("before-sanity-check", function (t) {\n      var r = t.element;\n\n      if (r.matches(p)) {\n        t.code = "", r.setAttribute(d, l);\n        var i = r.appendChild(document.createElement("CODE"));\n        i.textContent = "Loading…";\n        var e = t.language;\n        i.className = "language-" + e;\n        var n = Prism.plugins.autoloader;\n        n && n.loadLanguages(e);\n        var a = r.getAttribute("data-adapter"),\n            o = null;\n\n        if (a) {\n          if ("function" != typeof window[a]) return r.setAttribute(d, m), void (i.textContent = function (t) {\n            return \'✖ Error: JSONP adapter function "\' + t + "\\" doesn\'t exist";\n          }(a));\n          o = window[a];\n        }\n\n        var u = r.getAttribute("data-jsonp");\n        !function (t, e, n, a) {\n          var r = "prismjsonp" + f++,\n              i = document.createElement("a");\n          i.href = t, i.href += (i.search ? "&" : "?") + (e || "callback") + "=" + r;\n          var o = document.createElement("script");\n          o.src = i.href, o.onerror = function () {\n            s(), a("network");\n          };\n          var u = setTimeout(function () {\n            s(), a("timeout");\n          }, Prism.plugins.jsonphighlight.timeout);\n\n          function s() {\n            clearTimeout(u), document.head.removeChild(o), delete window[r];\n          }\n\n          window[r] = function (t) {\n            s(), n(t);\n          }, document.head.appendChild(o);\n        }(u, r.getAttribute("data-callback"), function (t) {\n          var e = null;\n          if (o) e = o(t, r);else for (var n = 0, a = s.length; n < a && null === (e = s[n].adapter(t, r)); n++) {\n            ;\n          }\n          null === e ? (r.setAttribute(d, m), i.textContent = "✖ Error: Cannot parse response (perhaps you need an adapter function?)") : (r.setAttribute(d, c), i.textContent = e, Prism.highlightElement(i));\n        }, function () {\n          r.setAttribute(d, m), i.textContent = function (t) {\n            return "✖ Error: Timeout loading " + t;\n          }(u);\n        });\n      }\n    }), Prism.plugins.jsonphighlight = {\n      timeout: 5e3,\n      registerAdapter: t,\n      removeAdapter: function removeAdapter(e) {\n        if ("string" == typeof e && (e = n(e)), "function" == typeof e) {\n          var t = s.findIndex(function (t) {\n            return t.adapter === e;\n          });\n          0 <= t && s.splice(t, 1);\n        }\n      },\n      highlight: function highlight(t) {\n        for (var e, n = (t || document).querySelectorAll(p), a = 0; e = n[a++];) {\n          Prism.highlightElement(e);\n        }\n      }\n    };\n  }\n\n  function t(t, e) {\n    e = e || t.name, "function" != typeof t || n(t) || n(e) || s.push({\n      adapter: t,\n      name: e\n    });\n  }\n\n  function n(t) {\n    if ("function" == typeof t) {\n      for (var e = 0; n = s[e++];) {\n        if (n.adapter.valueOf() === t.valueOf()) return n.adapter;\n      }\n    } else if ("string" == typeof t) {\n      var n;\n\n      for (e = 0; n = s[e++];) {\n        if (n.name === t) return n.adapter;\n      }\n    }\n\n    return null;\n  }\n}();\n"undefined" != typeof Prism && Prism.hooks.add("wrap", function (e) {\n  "keyword" === e.type && e.classes.push("keyword-" + e.content);\n});\n!function () {\n  if ("undefined" != typeof Prism && "undefined" != typeof document) {\n    var d = /(?:^|\\s)command-line(?:\\s|$)/,\n        f = "command-line-prompt",\n        m = "".startsWith ? function (e, t) {\n      return e.startsWith(t);\n    } : function (e, t) {\n      return 0 === e.indexOf(t);\n    };\n    Prism.hooks.add("before-highlight", function (e) {\n      var t = h(e);\n\n      if (!t.complete && e.code) {\n        var n = e.element.parentElement;\n\n        if (n && /pre/i.test(n.nodeName) && (d.test(n.className) || d.test(e.element.className))) {\n          var a = e.element.querySelector("." + f);\n          a && a.remove();\n          var s = e.code.split("\\n");\n          t.numberOfLines = s.length;\n          var o = t.outputLines = [],\n              r = n.getAttribute("data-output"),\n              i = n.getAttribute("data-filter-output");\n          if (null !== r) r.split(",").forEach(function (e) {\n            var t = e.split("-"),\n                n = parseInt(t[0], 10),\n                a = 2 === t.length ? parseInt(t[1], 10) : n;\n\n            if (!isNaN(n) && !isNaN(a)) {\n              n < 1 && (n = 1), a > s.length && (a = s.length), a--;\n\n              for (var r = --n; r <= a; r++) {\n                o[r] = s[r], s[r] = "";\n              }\n            }\n          });else if (i) for (var l = 0; l < s.length; l++) {\n            m(s[l], i) && (o[l] = s[l].slice(i.length), s[l] = "");\n          }\n          e.code = s.join("\\n");\n        } else t.complete = !0;\n      } else t.complete = !0;\n    }), Prism.hooks.add("before-insert", function (e) {\n      var t = h(e);\n\n      if (!t.complete) {\n        for (var n = e.highlightedCode.split("\\n"), a = t.outputLines || [], r = 0, s = a.length; r < s; r++) {\n          a.hasOwnProperty(r) && (n[r] = a[r]);\n        }\n\n        e.highlightedCode = n.join("\\n");\n      }\n    }), Prism.hooks.add("complete", function (e) {\n      if (function (e) {\n        return "command-line" in (e.vars = e.vars || {});\n      }(e)) {\n        var t = h(e);\n\n        if (!t.complete) {\n          var n,\n              a = e.element.parentElement;\n          d.test(e.element.className) && (e.element.className = e.element.className.replace(d, " ")), d.test(a.className) || (a.className += " command-line");\n          var r = t.numberOfLines || 0,\n              s = c("data-prompt", "");\n          if ("" !== s) n = p(\'<span data-prompt="\' + s + \'"></span>\', r);else n = p(\'<span data-user="\' + c("data-user", "user") + \'" data-host="\' + c("data-host", "localhost") + \'"></span>\', r);\n          var o = document.createElement("span");\n          o.className = f, o.innerHTML = n;\n\n          for (var i = t.outputLines || [], l = 0, m = i.length; l < m; l++) {\n            if (i.hasOwnProperty(l)) {\n              var u = o.children[l];\n              u.removeAttribute("data-user"), u.removeAttribute("data-host"), u.removeAttribute("data-prompt");\n            }\n          }\n\n          e.element.insertBefore(o, e.element.firstChild), t.complete = !0;\n        }\n      }\n\n      function c(e, t) {\n        return (a.getAttribute(e) || t).replace(/"/g, "&quot");\n      }\n    });\n  }\n\n  function p(e, t) {\n    for (var n = "", a = 0; a < t; a++) {\n      n += e;\n    }\n\n    return n;\n  }\n\n  function h(e) {\n    var t = e.vars = e.vars || {};\n    return t["command-line"] = t["command-line"] || {};\n  }\n}();\n!function () {\n  if ("undefined" != typeof Prism && "undefined" != typeof document) {\n    var i = [],\n        l = {},\n        d = function d() {};\n\n    Prism.plugins.toolbar = {};\n\n    var e = Prism.plugins.toolbar.registerButton = function (e, n) {\n      var t;\n      t = "function" == typeof n ? n : function (e) {\n        var t;\n        return "function" == typeof n.onClick ? ((t = document.createElement("button")).type = "button", t.addEventListener("click", function () {\n          n.onClick.call(this, e);\n        })) : "string" == typeof n.url ? (t = document.createElement("a")).href = n.url : t = document.createElement("span"), n.className && t.classList.add(n.className), t.textContent = n.text, t;\n      }, e in l ? console.warn(\'There is a button with the key "\' + e + \'" registered already.\') : i.push(l[e] = t);\n    },\n        t = Prism.plugins.toolbar.hook = function (a) {\n      var e = a.element.parentNode;\n\n      if (e && /pre/i.test(e.nodeName) && !e.parentNode.classList.contains("code-toolbar")) {\n        var t = document.createElement("div");\n        t.classList.add("code-toolbar"), e.parentNode.insertBefore(t, e), t.appendChild(e);\n        var r = document.createElement("div");\n        r.classList.add("toolbar");\n\n        var n = i,\n            o = function (e) {\n          for (; e;) {\n            var t = e.getAttribute("data-toolbar-order");\n            if (null != t) return (t = t.trim()).length ? t.split(/\\s*,\\s*/g) : [];\n            e = e.parentElement;\n          }\n        }(a.element);\n\n        o && (n = o.map(function (e) {\n          return l[e] || d;\n        })), n.forEach(function (e) {\n          var t = e(a);\n\n          if (t) {\n            var n = document.createElement("div");\n            n.classList.add("toolbar-item"), n.appendChild(t), r.appendChild(n);\n          }\n        }), t.appendChild(r);\n      }\n    };\n\n    e("label", function (e) {\n      var t = e.element.parentNode;\n\n      if (t && /pre/i.test(t.nodeName) && t.hasAttribute("data-label")) {\n        var n,\n            a,\n            r = t.getAttribute("data-label");\n\n        try {\n          a = document.querySelector("template#" + r);\n        } catch (e) {}\n\n        return a ? n = a.content : (t.hasAttribute("data-url") ? (n = document.createElement("a")).href = t.getAttribute("data-url") : n = document.createElement("span"), n.textContent = r), n;\n      }\n    }), Prism.hooks.add("complete", t);\n  }\n}();\n!function () {\n  function u(t, e) {\n    t.addEventListener("click", function () {\n      !function (t) {\n        navigator.clipboard ? navigator.clipboard.writeText(t.getText()).then(t.success, function () {\n          o(t);\n        }) : o(t);\n      }(e);\n    });\n  }\n\n  function o(e) {\n    var t = document.createElement("textarea");\n    t.value = e.getText(), t.style.top = "0", t.style.left = "0", t.style.position = "fixed", document.body.appendChild(t), t.focus(), t.select();\n\n    try {\n      var o = document.execCommand("copy");\n      setTimeout(function () {\n        o ? e.success() : e.error();\n      }, 1);\n    } catch (t) {\n      setTimeout(function () {\n        e.error(t);\n      }, 1);\n    }\n\n    document.body.removeChild(t);\n  }\n\n  "undefined" != typeof Prism && "undefined" != typeof document && (Prism.plugins.toolbar ? Prism.plugins.toolbar.registerButton("copy-to-clipboard", function (t) {\n    var e = t.element,\n        o = function (t) {\n      var e = {\n        copy: "Copy",\n        "copy-error": "Press Ctrl+C to copy",\n        "copy-success": "Copied!",\n        "copy-timeout": 5e3\n      };\n\n      for (var o in e) {\n        for (var n = "data-prismjs-" + o, c = t; c && !c.hasAttribute(n);) {\n          c = c.parentElement;\n        }\n\n        c && (e[o] = c.getAttribute(n));\n      }\n\n      return e;\n    }(e),\n        n = document.createElement("button");\n\n    n.className = "copy-to-clipboard-button", n.setAttribute("type", "button");\n    var c = document.createElement("span");\n    return n.appendChild(c), i("copy"), u(n, {\n      getText: function getText() {\n        return e.textContent;\n      },\n      success: function success() {\n        i("copy-success"), r();\n      },\n      error: function error() {\n        i("copy-error"), setTimeout(function () {\n          !function (t) {\n            window.getSelection().selectAllChildren(t);\n          }(e);\n        }, 1), r();\n      }\n    }), n;\n\n    function r() {\n      setTimeout(function () {\n        i("copy");\n      }, o["copy-timeout"]);\n    }\n\n    function i(t) {\n      c.textContent = o[t], n.setAttribute("data-copy-state", t);\n    }\n  }) : console.warn("Copy to Clipboard plugin loaded before Toolbar plugin."));\n}();\n\n//# sourceURL=webpack://terminal/./assets/js/prism.js?')}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}();var __webpack_exports__=__webpack_require__("./assets/js/prism.js")})();